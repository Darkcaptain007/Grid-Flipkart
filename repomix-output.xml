This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.csv
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
client/
  public/
    index.html
    manifest.json
    robots.txt
  src/
    Components/
      Cart/
        Cart.jsx
        CartItem.jsx
        EmptyCart.jsx
        GroupButton.jsx
        TotalView.jsx
      Header/
        CustomButtons.jsx
        Header.jsx
        Profile.jsx
        Search.jsx
      Home/
        Banner.jsx
        CategoryMenu.jsx
        MidSection.jsx
        MidSlide.jsx
        NarBar.jsx
        Slide.jsx
      ItemDetails/
        ActionItem.jsx
        DetailView.jsx
        ProductDetail.jsx
      Login/
        LoginDialog.jsx
      SearchResults/
        SearchResultsPage.jsx
      default.js
      Home.jsx
      NotFound.jsx
      Product.jsx
    constant/
      data.js
    context/
      ContextProvider.jsx
    razorpay/
      loadPayment.js
      razorpay.js
    reducers/
      reducer.js
    redux/
      actions/
        cartActions.js
        productActions.js
      constants/
        cartConstants.js
        productConstant.js
      reducers/
        cartReducer.js
        productReducer.js
      store.js
    service/
      api.js
    templates/
      TemplateProvider.js
    App.css
    App.js
    index.css
    index.js
  .gitignore
  package.json
server/
  constants/
    abbreviations.js
    product.js
  controller/
    cart-controller.js
    categoryController.js
    payment-controller.js
    product-controller.js
    search-controller.js
    user-controller.js
  database/
    db.js
    redis.js
  middleware/
    auth.js
  model/
    cartSchema.js
    categorySchema.js
    orderSchema.js
    productSchema.js
    userSchema.js
  routes/
    route.js
  utils/
    userHistory.js
  .gitignore
  importCategories.js
  importData.js
  index.js
  package.json
SRP/
  app/
    api/
      models.py
      routers.py
    core/
      config.py
    db/
      chroma_manager.py
    models/
      model_loader.py
    services/
      intent_classifier.py
      search_service.py
    main.py
  scripts/
    add_new_product.py
    bulk_indexer.py
    Example.py
    utils.py
  .dockerignore
  commands.txt
  docker-compose.yml
  Dockerfile
  test_client_with_k.py
  test_subcategory_intent.py
.gitignore
package.json
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
</file>

<file path="client/public/manifest.json">
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
</file>

<file path="client/public/robots.txt">
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
</file>

<file path="client/src/Components/Cart/Cart.jsx">
import { Box, makeStyles, Typography, Button, Grid } from '@material-ui/core';
import CartItem from './CartItem';
import { useEffect, useMemo } from 'react';
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { addToCart, removeFromCart } from '../../redux/actions/cartActions';
import TotalView from './TotalView';
import EmptyCart from './EmptyCart';
import { loadRazorpay } from '../../razorpay/loadPayment';


const useStyle = makeStyles(theme => ({
    component: {
        // marginTop: 55,
        padding: '30px 135px',
        display: 'flex',
        [theme.breakpoints.down('sm')]: {
            padding: '15px 0'
        }
    },
    leftComponent: {
        // width: '67%',
        paddingRight: 15,
        [theme.breakpoints.down('sm')]: {
            marginBottom: 15
        }
    },
    header: {
        padding: '15px 24px',
        background: '#fff'
    },
    bottom: {
        padding: '16px 22px',
        background: '#fff',
        boxShadow: '0 -2px 10px 0 rgb(0 0 0 / 10%)',
        borderTop: '1px solid #f0f0f0'
    },
    placeOrder: {
        display: 'flex',
        marginLeft: 'auto',
        background: '#fb641b',
        color: '#fff',
        borderRadius: 2,
        width: 250,
        height: 51
    }
}));

const Cart = ({ match, history }) => {
    const classes = useStyle();

    const cartDetails = useSelector(state => state.cart);
    const { cartItems } = cartDetails;

    const dispatch = useDispatch();
    
    useEffect(() => {
        if(cartItems && match.params.id !== cartItems.id)   
            dispatch(addToCart(match.params.id));
        console.log(cartItems);
    }, [dispatch, cartItems, match]);

    const removeItemFromCart = (id) => {
        dispatch(removeFromCart(id));
    }

    const buyNow = async () => {
        loadRazorpay(500);
    }

    const total = useMemo(() => {
    return cartItems.reduce((acc, item) => acc + (item.price.cost * item.quantity), 0);
  }, [cartItems]);
    return (
        <>
        { cartItems.length ? 
            <Grid container className={classes.component}>
                <Grid item lg={9} md={9} sm={12} xs={12} className={classes.leftComponent}>
                    <Box className={classes.header}>
                        <Typography style={{fontWeight: 600, fontSize: 18}}>My Cart ({cartItems?.length})</Typography>
                    </Box>
                        {   cartItems.map(item => (
                                <CartItem item={item} removeItemFromCart={removeItemFromCart}/>
                            ))
                        }
                    <Box className={classes.bottom}>
                        <Button onClick={() => buyNow()} variant="contained" className={classes.placeOrder}>Place Order</Button>
                    </Box>
                </Grid>
                <Grid item lg={3} md={3} sm={12} xs={12}>
                    <TotalView cartItems={cartItems} />
                </Grid>
            </Grid> : <EmptyCart />
        }
        </>

    )
}
const MemoizedCartItem = React.memo(CartItem);
export default Cart;
</file>

<file path="client/src/Components/Cart/CartItem.jsx">
import { Card, makeStyles, Box, Typography, Button } from '@material-ui/core';
import clsx from 'clsx';
import GroupButton from './GroupButton';

const useStyle = makeStyles({
    component: {
        borderTop: '1px solid #f0f0f0',
        borderRadius: 0,
        display: 'flex'
    },
    leftComponent: {
        margin: 20, 
        display: 'flex',
        flexDirection: 'column'
    },
    image: {
        height: 110,
        width: 110
    },
    mid: {
        margin: 20
    },
    greyTextColor: {
        color: '#878787'
    },
    smallText: {
        fontSize: 14,
    },
    price: {
        fontSize: 18,
        fontWeight: 600
    },
    remove: {
        marginTop: 20,
        fontSize: 16
    }
});

const CartItem = ({ item, removeItemFromCart }) => {
    console.log(item)
    const classes = useStyle();
    const fassured = 'https://static-assets-web.flixcart.com/www/linchpin/fk-cp-zion/img/fa_62673a.png';

    return (
        <Card className={classes.component}>
            <Box className={classes.leftComponent}>
                <img src={item.url} className={classes.image} alt="" />
                <GroupButton />
            </Box>
            <Box className={classes.mid}>
                <Typography>{item.title.longTitle}</Typography>
                <Typography className={clsx(classes.greyTextColor, classes.smallText)} style={{ marginTop: 10 }}>Seller:RetailNet
                    <span><img src={fassured} style={{ width: 50, marginLeft: 10 }} alt="" /></span>
                </Typography>
                <Typography style={{margin: '20px 0'}}>
                    <span className={classes.price}>₹{item.price.cost}</span>&nbsp;&nbsp;&nbsp;
                    <span className={classes.greyTextColor}><strike>₹{item.price.mrp}</strike></span>&nbsp;&nbsp;&nbsp;
                    <span style={{ color: '#388E3C' }}>{item.price.discount} off</span>
                </Typography>
                <Button className={classes.remove} onClick={() => removeItemFromCart(item.id)}>Remove</Button>
            </Box>
        </Card>
    )
}

export default CartItem;
</file>

<file path="client/src/Components/Cart/EmptyCart.jsx">
import { makeStyles, Typography, Box } from '@material-ui/core';

const useStyle = makeStyles({
    component: {
        width: '80%%',
        height: '65vh',
        background: '#fff',
        margin: '80px 140px'
    },
    image: {
        width: '15%'
    },
    container: {
        textAlign: 'center',
        paddingTop: 70
    }
})


const EmptyCart = () => {
    const imgurl = 'https://rukminim1.flixcart.com/www/800/800/promos/16/05/2019/d438a32e-765a-4d8b-b4a6-520b560971e8.png?q=90';
    const classes = useStyle();

    return (
        <Box className={classes.component}>
            <Box className={classes.container}>
                <img src={imgurl} className={classes.image} alt="" />
                <Typography>Your cart is empty!</Typography>
                <span>Add items to it now.</span>
            </Box>
        </Box>
    )
}

export default EmptyCart;
</file>

<file path="client/src/Components/Cart/GroupButton.jsx">
import React, { useState } from "react";
import { ButtonGroup, Button, makeStyles } from "@material-ui/core";

const useStyle = makeStyles({
    component: {
        marginTop: 30
    },
    button :{
        borderRadius: '50%'
    }
})

const GroupedButton = () => {
    const classes = useStyle();
    const [ counter, setCounter ] = useState(1);

    const handleIncrement = () => {
        setCounter(counter => counter + 1 );
    };

    const handleDecrement = () => {
        setCounter(counter => counter - 1 );
    };

    return (
        <ButtonGroup className={classes.component} >
            <Button className={classes.button} onClick={() => handleDecrement()} disabled={counter === 0}>-</Button>
            <Button disabled>{counter}</Button>
            <Button className={classes.button} onClick={() => handleIncrement()}>+</Button>
        </ButtonGroup>
    );
}

export default GroupedButton;
</file>

<file path="client/src/Components/Cart/TotalView.jsx">
import { useState, useEffect } from 'react';
import { Box, makeStyles, Typography } from '@material-ui/core';
import clsx from 'clsx';

const useStyle = makeStyles({
    component: {
        // width: '30%'
    },
    header: {
        padding: '15px 24px',
        background: '#fff'
    },
    greyTextColor: {
        color: '#878787'
    },
    container: {
        '& > *': {
            marginBottom: 20,
            fontSize: 14
        }
    },
    price: {
        float: 'right'
    },
    totalAmount: {
        fontSize: 18,
        fontWeight: 600,
        borderTop: '1px dashed #e0e0e0',
        padding: '20px 0',
        borderBottom: '1px dashed #e0e0e0'
    }
})


const TotalView = ({ cartItems }) => {
    const classes = useStyle();
    const [price, setPrice] = useState(0);
    const [discount, setDiscount] = useState(0)


    useEffect(() => {
        const totalAmount = () => {
            let price = 0, discount = 0;
            console.log(cartItems);
            cartItems.map(item => {
                price += item.price.mrp
                discount += (item.price.mrp - item.price.cost) 
            })
            setPrice(price);
            setDiscount(discount);
        };
        totalAmount();
    }, [cartItems]);
    
    
    return (
        <Box className={classes.component}>
            <Box className={classes.header} style={{borderBottom: '1px solid #f0f0f0'}}>
                <Typography className={classes.greyTextColor}>PRICE DETAILS</Typography>
            </Box>
            <Box className={clsx(classes.header, classes.container)}>
                <Typography>Price ({cartItems?.length} item)<span className={classes.price}>₹{price}</span></Typography>
                <Typography>Discount<span className={classes.price}>-₹{discount}</span></Typography>
                <Typography>Delivery Charges<span className={classes.price}>₹40</span></Typography>
                <Typography className={classes.totalAmount}>Total Amount<span className={classes.price}>₹{price - discount + 40}</span></Typography>
                <Typography style={{fontSize: 16, color: 'green'}}>You will save ₹{discount - 40} on this order</Typography>
            </Box>
        </Box>
    )
}

export default TotalView;
</file>

<file path="client/src/Components/Home/Banner.jsx">
import Carousel from 'react-material-ui-carousel'
import { makeStyles } from '@material-ui/core'
import { bannerData } from '../../constant/data';


const useStyle = makeStyles(theme => ({
    container: {
    },
    image: {
        width: '100%',
        height: 280,
        [theme.breakpoints.down('sm')]: {
            objectFit: 'cover',
            height: 180
        }
    }
}))

const Banner = () => {
    const classes = useStyle();
    return (
        <Carousel 
            autoPlay={true} 
            animation="slide" 
            indicators={false}
            navButtonsAlwaysVisible={true}
            cycleNavigation={true}
            className={classes.container}
            StylesProvider
            navButtonsProps={{ 
                style: {
                    color: '#494949',
                    backgroundColor: '#FFFFFF',
                    borderRadius: 0,
                    margin: 0,
                    width: 50,
                }
            }}
        >
            {
                bannerData.map(image => (
                    <img src={image} className={classes.image} alt="" />
                ))
            }
        </Carousel>
    )
}

export default Banner;
</file>

<file path="client/src/Components/Home/CategoryMenu.jsx">
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { Box, Typography, makeStyles } from '@material-ui/core';

const useStyles = makeStyles(theme => ({
  categoryRow: { /* your styles (horizontal, scrollable row) */ },
  categoryTab: { /* styles for each category tab */ },
  subcategoryDropdown: {
    position: 'absolute',
    background: '#fff',
    boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
    borderRadius: '4px',
    padding: 8,
    marginTop: 8,
    zIndex: 1000,
    minWidth: 160,
  },
  subcategoryItem: {
    padding: '6px 12px',
    cursor: 'pointer',
    '&:hover': { backgroundColor: '#f0f0f0' }
  }
}));

const CategoryMenu = () => {
  const classes = useStyles();
  const [categories, setCategories] = useState([]);
  const [subcategories, setSubcategories] = useState([]);
  const [hoveredCategory, setHoveredCategory] = useState(null);

  useEffect(() => {
    axios.get('/api/categories')
      .then(res => setCategories(res.data))
      .catch(err => console.error('Failed to fetch categories', err));
  }, []);

  const handleCategoryHover = (category) => {
    setHoveredCategory(category);
    axios.get(`/api/categories/${encodeURIComponent(category)}/subcategories`)
      .then(res => setSubcategories(res.data))
      .catch(err => {
        setSubcategories([]);
        console.error('Failed to fetch subcategories', err);
      });
  };

  const handleCategoryLeave = () => {
    setHoveredCategory(null);
    setSubcategories([]);
  };

  return (
    <Box className={classes.categoryRow}>
      {categories.map(cat => (
        <Box
          key={cat}
          className={classes.categoryTab}
          onMouseEnter={() => handleCategoryHover(cat)}
          onMouseLeave={handleCategoryLeave}
          style={{ position: 'relative' }}
        >
          <Typography>{cat}</Typography>

          {/* Subcategory dropdown */} 
          {hoveredCategory === cat && subcategories.length > 0 && (
            <Box className={classes.subcategoryDropdown}>
              {subcategories.map(sub => (
                <Typography key={sub} className={classes.subcategoryItem}>
                  {sub}
                </Typography>
              ))}
            </Box>
          )}
        </Box>
      ))}
    </Box>
  );
};

export default CategoryMenu;
</file>

<file path="client/src/Components/Home/MidSection.jsx">
import { makeStyles, Grid } from '@material-ui/core';
import clsx from 'clsx';

const ImageURL = [
    'https://rukminim1.flixcart.com/flap/960/960/image/2f30db9425df5cec.jpg?q=50',
    'https://rukminim1.flixcart.com/flap/960/960/image/084789479074d2b2.jpg',
    'https://rukminim1.flixcart.com/flap/960/960/image/1ce0c4c1fb501b45.jpg?q=50'
];

const useStyle = makeStyles(theme => ({
    wrapper: {
        display: 'flex',
        marginTop: 20,
        justifyContent: 'space-between'
    },
    image: {
        width: '100%'
    },
    help: {
        [theme.breakpoints.down('md')]: {
            objectFit: 'cover',
            height: 120
        }
    }
}));

const MidSection = () => {
    const classes = useStyle();
    const url = 'https://rukminim1.flixcart.com/flap/3006/433/image/4789bc3aefd54494.jpg?q=50';
    return (
        <>
            <Grid lg={12} sm={12} md={12} xs={12} container className={classes.wrapper}>
                {
                    ImageURL.map(image => (
                        <Grid item lg={4} md={4} sm={12} xs={12}>
                            <img src={image} className={classes.image} alt="" />
                        </Grid>
                    ))
                }
            </Grid>
            <img src={url} className={clsx(classes.wrapper, classes.help)} style={{width: '100%'}} alt="" />
        </>
    )
}

export default MidSection;
</file>

<file path="client/src/Components/Home/MidSlide.jsx">
import { Box, makeStyles } from '@material-ui/core';
import Slide from './Slide';

const useStyle = makeStyles(theme => ({
    component: {
        display: 'flex'
    },
    leftComponent: {
        width: '83%',
        [theme.breakpoints.down('md')]: {
            width: '100%'
        }
    },
    rightComponent: {
        marginTop: 12,
        background: '#FFFFFF',
        width: '17%',
        marginLeft: 10,
        padding: 5,
        [theme.breakpoints.down('md')]: {
            display: 'none'
        }
    }
}));

const MidSlide = ({ products }) => {
    const classes = useStyle();
    const adURL = 'https://rukminim1.flixcart.com/flap/464/708/image/633789f7def60050.jpg?q=70';

    return (
        <Box className={classes.component}>
            <Box className={classes.leftComponent}>
                <Slide 
                    data={products} 
                    title='Deals of the Day'
                    timer={true} 
                    multi={true} 
                />
            </Box>
            <Box className={classes.rightComponent}>
                <img src={adURL} style={{width: 232}} alt="" />
            </Box>
        </Box>
    )
}

export default MidSlide;
</file>

<file path="client/src/Components/Home/Slide.jsx">
import { Box, Typography, makeStyles, Button, Divider } from '@material-ui/core';
import Carousel from 'react-multi-carousel';
import "react-multi-carousel/lib/styles.css";
import Countdown from 'react-countdown';
import { Link } from 'react-router-dom';


const responsive = {
    desktop: {
        breakpoint: { max: 3000, min: 1024 },
        items: 5,
    },
    tablet: {
        breakpoint: { max: 1024, min: 464 },
        items: 2,
    },
    mobile: {
        breakpoint: { max: 464, min: 0 },
        items: 1,
    }
};

const useStyle = makeStyles(theme => ({
    component: {
        marginTop: 12,
        background: '#FFFFFF'
    }, 
    timer: {
        color: '#7f7f7f',
        marginLeft: 10,
        display: 'flex',
        alignItems: 'center',
        [theme.breakpoints.down('sm')]: {
            display: 'none'
        }
    },
    image: {
        width: 'auto',
        height: 150
    },
    text: {
        fontSize: 14,
        marginTop: 5
    },
    deal: {
        display: 'flex',
        padding: '15px 20px'
    },
    dealText: {
        fontSize: 22,
        fontWeight: 600,
        lineHeight: '32px',
        marginRight: 25
    },
    button: {
        marginLeft: 'auto',
        backgroundColor: '#2874f0',
        borderRadius: 2,
        fontSize: 13
    },
    wrapper: {
        padding: '25px 15px'
    },
    
}));

const MultiSlide = ({ data, timer, title }) => {
    const classes = useStyle();
    const timerURL = 'https://static-assets-web.flixcart.com/www/linchpin/fk-cp-zion/img/timer_a73398.svg';

    const renderer = ({ hours, minutes, seconds }) => {
        return <span className={classes.timer}>{hours} : {minutes} : {seconds}  Left</span>;
    };
    
    return (
        <Box className={classes.component}>
            <Box className={classes.deal}>
                <Typography className={classes.dealText}>{title}</Typography>
                {
                    timer && <Box className={classes.timer}>
                                <img src={timerURL} style={{ width: 24 }} alt='time clock' />
                                <Countdown date={Date.now() + 5.04e+7} renderer={renderer} />
                        </Box>
                }
                <Button variant="contained" color="primary" className={classes.button}>View All</Button>
            </Box>
            <Divider />
            <Carousel
                swipeable={false}
                draggable={false}
                responsive={responsive}
                centerMode={true}
                infinite={true}
                autoPlay={true}
                autoPlaySpeed={10000}
                keyBoardControl={true}
                showDots={false}
                containerClass="carousel-container"
                // removeArrowOnDeviceType={["tablet", "mobile"]}
                dotListClass="custom-dot-list-style"
                itemClass="carousel-item-padding-40-px"
            >
                {
                    data.map(temp => (
                        <Link to={`product/${temp.id}`} style={{textDecoration: 'none'}}>
                            <Box textAlign="center" className={classes.wrapper}>
                                <img src={temp.url} className={classes.image} alt="" />
                                <Typography className={classes.text} style={{ fontWeight: 600, color: '#212121' }}>{temp.title.shortTitle}</Typography>
                                <Typography className={classes.text} style={{ color: 'green' }}>{temp.discount}</Typography>
                                <Typography className={classes.text} style={{ color: '#212121', opacity: '.6' }}>{temp.tagline}</Typography>
                            </Box>
                        </Link>
                    ))
                }
            </Carousel>
        </Box>
    )
}

const Slide = (props) => {
    return (
        <>
            {
                props.multi === true ? <MultiSlide {...props} /> : ''      
            }
        </>
    )
}

export default Slide;
</file>

<file path="client/src/Components/ItemDetails/ActionItem.jsx">
import { useState, useContext } from 'react';
import { Button, Box, makeStyles } from '@material-ui/core';
import { ShoppingCart as Cart, FlashOn as Flash } from '@material-ui/icons';
import clsx from 'clsx';
import { useHistory } from 'react-router-dom';
import { LoginContext } from '../../context/ContextProvider';
import { addToCart } from '../../redux/actions/cartActions';
import { useDispatch } from 'react-redux';
import { loadRazorpay } from '../../razorpay/loadPayment';


const useStyle = makeStyles(theme => ({
    leftContainer: {
        minWidth: '40%',
        // textAlign: 'center',
        padding: '40px 0 0 80px',
        [theme.breakpoints.down('md')]: {
            padding: '20px 40px'
        }
    },
    productImage: {
        padding: '15px 20px',
        border: '1px solid #f0f0f0',
        width: '95%'
    },
    button: {
        width: '46%',
        borderRadius: 2,
        height: 50
    },
    addToCart: {
        background: '#ff9f00',
        color: '#FFF'
    },
    buyNow:{
        background: '#fb641b',
        color: '#FFF'
    }
}));

const ActionItem = ({ product }) => {
    const classes = useStyle();
    const history = useHistory();
    const dispatch = useDispatch();

    const buyNow = async () => {
       loadRazorpay(600);
    }

    const addItemToCart = () => {
        dispatch(addToCart(product.id, 1));
        history.push('/cart');
    }

    return (
        <Box className={classes.leftContainer}>
            <img src={product.detailUrl} className={classes.productImage} alt="" /><br />
            <Button onClick={() => addItemToCart()} className={clsx(classes.button, classes.addToCart)} style={{marginRight: 10}} variant="contained"><Cart />Add to Cart</Button>
            <Button onClick={() => buyNow()} className={clsx(classes.button, classes.buyNow)} variant="contained"><Flash /> Buy Now</Button>
        </Box>
    )
}

export default ActionItem;
</file>

<file path="client/src/Components/ItemDetails/DetailView.jsx">
import { useEffect } from 'react';
import { Box, Grid, makeStyles, Typography } from '@material-ui/core';
import { LocalOffer as Badge } from '@material-ui/icons';
import ProductDetail from './ProductDetail';
import ActionItem from './ActionItem';
import { useDispatch, useSelector } from 'react-redux';
import { getProductDetails } from '../../redux/actions/productActions';

const useStyles = makeStyles(theme => ({
    component: {
        marginTop: 55,
        background: '#F2F2F2'
    },
    container: {
        background: '#FFFFFF',
        margin: '0 80px',
        display: 'flex',
        [theme.breakpoints.down('md')]: {
            margin: 0
        }
    },
    rightContainer: {
        marginTop: 50,
        padding: '0 25px',
        '& > *': {
            marginTop: 10
        }
    },
    price: {
        fontSize: 28
    },
    smallText: {
        fontSize: 14,
    },
    greyTextColor: {
        color: '#878787'
    },
    badge: {
        marginRight: 10,
        color: '#00CC00',
        fontSize: 15
    }
}));

const DetailView = ({ match }) => {
    const classes = useStyles();
    const fassured = 'https://static-assets-web.flixcart.com/www/linchpin/fk-cp-zion/img/fa_62673a.png';
    
    // Get product data and loading status from Redux store
    const { loading, product } = useSelector(state => state.getProductDetails);
    const dispatch = useDispatch();
    
    useEffect(() => {
        if (match.params.id) {
            dispatch(getProductDetails(match.params.id));
        }
        console.log('DetailView looking for ID:', match.params.id);

    }, [dispatch, match.params.id]);

    console.log('Product data:', product); // Debug log
    console.log('Loading:', loading); // Debug log

    if (loading) {
        return (
            <Box className={classes.component}>
                <Typography style={{ padding: '50px', textAlign: 'center' }}>Loading...</Typography>
            </Box>
        );
    }

    if (!product || !Object.keys(product).length) {
        return (
            <Box className={classes.component}>
                <Typography style={{ padding: '50px', textAlign: 'center' }}>Product not found</Typography>
            </Box>
        );
    }

    return (
        <Box className={classes.component}>
            <Grid container className={classes.container}>
                <Grid item lg={4} md={4} sm={8} xs={12}>
                    <ActionItem product={product} />
                </Grid>
                <Grid item lg={8} md={8} sm={8} xs={12} className={classes.rightContainer}>
                    <Typography>{product.title?.longTitle || 'Product Title'}</Typography>
                    
                    <Typography style={{marginTop: 5, color: '#878787', fontSize: 14}}>
                        8 Ratings & 1 Reviews
                        <span><img src={fassured} style={{width: 77, marginLeft: 20}} alt="" /></span>
                    </Typography>
                    
                    <Typography>
                        <span className={classes.price}>₹{product.price?.cost}</span>&nbsp;&nbsp;&nbsp;
                        <span className={classes.greyTextColor}><strike>₹{product.price?.mrp}</strike></span>&nbsp;&nbsp;&nbsp;
                        <span style={{color: '#388E3C'}}>{product.price?.discount} off</span>
                    </Typography>
                    
                    <ProductDetail product={product} />
                </Grid>
            </Grid>
        </Box>
    )
}

export default DetailView;
</file>

<file path="client/src/Components/ItemDetails/ProductDetail.jsx">
import { Box, Typography, makeStyles, Table, TableBody, TableRow, TableCell } from '@material-ui/core';
import { LocalOffer as Badge } from '@material-ui/icons';

const useStyle = makeStyles({
    smallText: {
        fontSize: 14,
        verticalAlign: 'baseline',
        '& > *' :{
            fontSize: 14,
            marginTop: 10
        }
    },
    greyTextColor: {
        color: '#878787'
    },
    badge: {
        marginRight: 10,
        color: '#00CC00',
        fontSize: 15
    },
    wrapper: {
        display: 'flex'
    }
});

const ProductDetail = ({ product }) => {
    const classes = useStyle();
    const adURL = 'https://rukminim1.flixcart.com/lockin/774/185/images/CCO__PP_2019-07-14.png?q=50';
    const date = new Date(new Date().getTime()+(5*24*60*60*1000));
    
    return (
        <>
            <Typography>Available offers</Typography>
            <Box className={classes.smallText}>
                <Typography><Badge className={classes.badge} />Bank Offer 5% Unlimited Cashback on Flipkart Axis Bank Credit Card</Typography>
                <Typography><Badge className={classes.badge} />Bank Offer 10% Off on Bank of Baroda Mastercard debit card first time transaction, Terms and Condition apply</Typography>
                <Typography><Badge className={classes.badge} />Purchase this Furniture or Appliance and Get Extra ₹500 Off on Select ACs</Typography>
                <Typography><Badge className={classes.badge} />Partner OfferExtra 10% off upto ₹500 on next furniture purchase</Typography>
            </Box>
            <Table>
                <TableBody>
                    <TableRow className={classes.smallText}>
                        <TableCell className={classes.greyTextColor}>Delivery</TableCell>
                        <TableCell style={{ fontWeight: 600 }}>Delivery by {date.toDateString()} | ₹40</TableCell>
                    </TableRow>
                    <TableRow className={classes.smallText}>
                        <TableCell className={classes.greyTextColor}>Warranty</TableCell>
                        <TableCell>No Warranty</TableCell>
                    </TableRow>
                    <TableRow className={classes.smallText}>
                        <TableCell className={classes.greyTextColor}>Seller</TableCell>
                        <TableCell className={classes.smallText}>
                            <span style={{ color: '#2874f0' }}>SuperComNet</span>
                            <Typography>GST invoice available</Typography>
                            <Typography>View more sellers starting from ₹329</Typography>
                        </TableCell>
                    </TableRow>
                    <TableRow>
                        <TableCell colSpan={2}>
                            <img src={adURL} style={{ width: 390 }} alt="" />
                        </TableCell>
                    </TableRow>
                    <TableRow className={classes.smallText}>
                        <TableCell className={classes.greyTextColor}>Description</TableCell>
                        <TableCell>{product.description}</TableCell>
                    </TableRow>
                </TableBody>
            </Table>
        </>
    )
}

export default ProductDetail;
</file>

<file path="client/src/Components/Login/LoginDialog.jsx">
import React, { useState, useEffect } from 'react';
import { Dialog, DialogContent, TextField, Box, Button, makeStyles, Typography } from '@material-ui/core';
import { authenticateLogin, authenticateSignup } from '../../service/api';

const useStyle = makeStyles({
  component: {
    height: '70vh',
    width: '90vh',
    maxWidth: 'unset !important'
  },
  image: {
    backgroundImage: `url(${'https://static-assets-web.flixcart.com/www/linchpin/fk-cp-zion/img/login_img_c4a81e.png'})`,
    background: '#2874f0',
    backgroundPosition: 'center 85%',
    backgroundRepeat: 'no-repeat',
    height: '70vh',
    width: '40%',
    padding: '45px 35px',
    '& > *': {
      color: '#FFFFFF',
      fontWeight: 600
    }
  },
  login: {
    padding: '25px 35px',
    display: 'flex',
    flex: 1,
    flexDirection: 'column',
    '& > *': {
      marginTop: 20
    }
  },
  loginbtn: {
    textTransform: 'none',
    background: '#FB641B',
    color: '#fff',
    height: 48,
    borderRadius: 2
  },
  requestbtn: {
    textTransform: 'none',
    background: '#fff',
    color: '#2874f0',
    height: 48,
    borderRadius: 2,
    boxShadow: '0 2px 4px 0 rgb(0 0 0 / 20%)'
  },
  text: {
    color: '#878787',
    fontSize: 12
  },
  createText: {
    margin: 'auto 0 5px 0',
    textAlign: 'center',
    color: '#2874f0',
    fontWeight: 600,
    fontSize: 14,
    cursor: 'pointer'
  },
  error: {
    fontSize: 10,
    color: '#ff6161',
    lineHeight: 0,
    marginTop: 10,
    fontWeight: 600
  }
});

const loginInitialValues = {
  email: '',
  password: ''
};

const signupInitialValues = {
  firstname: '',
  lastname: '',
  username: '',
  email: '',
  password: '',
  phone: ''
};

const accountInitialValues = {
  login: {
    view: 'login',
    heading: 'Login',
    subHeading: 'Get access to your Orders, Wishlist and Recommendations'
  },
  signup: {
    view: 'signup',
    heading: "Looks like you're new here",
    subHeading: 'Signup to get started'
  }
};

const LoginDialog = ({ open, setOpen, setAccount }) => {
  const classes = useStyle();
  const [login, setLogin] = useState(loginInitialValues);
  const [signup, setSignup] = useState(signupInitialValues);
  const [error, showError] = useState(false);
  const [account, toggleAccount] = useState(accountInitialValues.login);

  useEffect(() => {
    showError(false);
  }, [login]);

  const onValueChange = (e) => {
    setLogin({ ...login, [e.target.name]: e.target.value });
  };

  const onInputChange = (e) => {
    setSignup({ ...signup, [e.target.name]: e.target.value });
  };

  const loginUser = async () => {
    let response = await authenticateLogin(login);
    if (!response || !response.data || !response.data.token) {
      showError(true);
      return;
    }
    showError(false);
    try {
      // UPDATED: Store full user object as JSON (ensure it's an object)
      const userData = {
        username: response.data.user.username, // Extract what you need
        // Add other fields if available, e.g., id: response.data.user.id
      };
      localStorage.setItem('token', response.data.token);
      localStorage.setItem('user', JSON.stringify(userData)); // Store as object
      console.log('Stored user in localStorage:', userData); // Debug log
      setAccount(userData.username);
      handleClose();
    } catch (err) {
      console.error('Error storing user:', err);
    }
  };

  const signupUser = async () => {
    try {
      let response = await authenticateSignup(signup);
      if (!response) throw new Error('No response from server');
      // UPDATED: Store full user object as JSON (ensure it's an object)
      const userData = {
        username: response.data.user.username || signup.username, // Fallback if response doesn't have it
        // Add other fields if available
      };
      localStorage.setItem('token', response.data.token);
      localStorage.setItem('user', JSON.stringify(userData)); // Store as object
      console.log('Stored user in localStorage:', userData); // Debug log
      setAccount(userData.username);
      handleClose();
    } catch (error) {
      if (error.response?.status === 409 || error.response?.status === 401) {
        alert(error.response.data.message || 'User already exists');
      } else {
        alert('Signup failed: ' + (error.message || 'Unknown error'));
      }
    }
  };

  const toggleSignup = () => {
    toggleAccount(accountInitialValues.signup);
  };

  const handleClose = () => {
    setOpen(false);
    toggleAccount(accountInitialValues.login);
  };

  return (
    <Dialog open={open} onClose={handleClose} maxWidth="md">
      <DialogContent className={classes.component}>
        <Box style={{ display: 'flex' }}>
          <Box className={classes.image}>
            <Typography variant="h5">{account.heading}</Typography>
            <Typography style={{ marginTop: 20 }}>{account.subHeading}</Typography>
          </Box>
          {account.view === 'login' ? (
            <Box className={classes.login}>
              <TextField onChange={onValueChange} name="email" label="Enter Email/Mobile number" />
              {error && <Typography className={classes.error}>Please enter valid Email ID/Mobile number</Typography>}
              <TextField onChange={onValueChange} name="password" label="Enter Password" />
              <Typography className={classes.text}>By continuing, you agree to Flipkart's Terms of Use and Privacy Policy.</Typography>
              <Button onClick={loginUser} className={classes.loginbtn}>Login</Button>
              <Typography className={classes.text} style={{ textAlign: 'center' }}>OR</Typography>
              <Button className={classes.requestbtn}>Request OTP</Button>
              <Typography className={classes.createText} onClick={toggleSignup}>New to Flipkart? Create an account</Typography>
            </Box>
          ) : (
            <Box className={classes.login}>
              <TextField onChange={onInputChange} name="firstname" label="Enter Firstname" />
              <TextField onChange={onInputChange} name="lastname" label="Enter Lastname" />
              <TextField onChange={onInputChange} name="username" label="Enter Username" />
              <TextField onChange={onInputChange} name="email" label="Enter Email" />
              <TextField onChange={onInputChange} name="password" label="Enter Password" />
              <TextField onChange={onInputChange} name="phone" label="Enter Phone" />
              <Button onClick={signupUser} className={classes.loginbtn}>Continue</Button>
            </Box>
          )}
        </Box>
      </DialogContent>
    </Dialog>
  );
};

export default LoginDialog;
</file>

<file path="client/src/Components/default.js">
// export { default as Cart } from './Cart';
export { default as Home } from './Home';
export { default as Product } from './Product';
// export { default as Header} from './Header';
export { default as NotFound } from './NotFound';
</file>

<file path="client/src/Components/NotFound.jsx">
const NotFound = () => {
    return (
        <p>Not Found! 404</p>
    )
}

export default NotFound;
</file>

<file path="client/src/Components/Product.jsx">
const Product = () => {
    return (
        <p>Hi from Product</p>
    )
}

export default Product;
</file>

<file path="client/src/constant/data.js">
export const navData = [
    { url: 'https://rukminim1.flixcart.com/flap/128/128/image/f15c02bfeb02d15d.png?q=100', text: 'Top Offers' },
    { url: 'https://rukminim1.flixcart.com/flap/128/128/image/29327f40e9c4d26b.png?q=100', text: 'Grocery' },
    { url: 'https://rukminim1.flixcart.com/flap/128/128/image/22fddf3c7da4c4f4.png?q=100', text: 'Mobile' },
    { url: 'https://rukminim1.flixcart.com/flap/128/128/image/82b3ca5fb2301045.png?q=100', text: 'Fashion' },
    { url: 'https://rukminim1.flixcart.com/flap/128/128/image/69c6589653afdb9a.png?q=100', text: 'Electronics' },
    { url: 'https://rukminim1.flixcart.com/flap/128/128/image/ee162bad964c46ae.png?q=100', text: 'Home' },
    { url: 'https://rukminim1.flixcart.com/flap/128/128/image/0ff199d1bd27eb98.png?q=100', text: 'Appliances' },
    { url: 'https://rukminim1.flixcart.com/flap/128/128/image/71050627a56b4693.png?q=100', text: 'Travel' },
    { url: 'https://rukminim1.flixcart.com/flap/128/128/image/dff3f7adcf3a90c6.png?q=100', text: 'Beauty, Toys & More' }
];

export const bannerData = [
    'https://rukminim1.flixcart.com/flap/3376/560/image/d117a62eb5fbb8e1.jpg?q=50',
    'https://rukminim1.flixcart.com/flap/3376/560/image/57267a180af306fe.jpg?q=50',
    'https://rukminim1.flixcart.com/flap/3376/560/image/ae9966569097a8b7.jpg?q=50',
    'https://rukminim1.flixcart.com/flap/3376/560/image/f6202f13b6f89b03.jpg?q=50'
]

export const dealData = [
    { 
        id: 'product1',
        url: 'https://rukminim1.flixcart.com/image/200/200/khf63680/cases-covers/back-cover/d/7/g/spigen-acs02256-original-imafxfgbffqaugur.jpeg?q=70', 
        detailUrl: '',
        title: {
            shortTitle: 'Mobile Covers'
        }, 
        discount: 'Extra 10% Off', 
        tagline: 'Deal of the day' 
    },
    { 
        id: 'product2',
        url: 'https://rukminim1.flixcart.com/image/200/200/k5lcvbk0/moisturizer-cream/9/w/g/600-body-lotion-aloe-hydration-for-normal-skin-nivea-lotion-original-imafz8jb3ftt8gf9.jpeg?q=70', 
        title: {
            shortTitle: 'Skin & Hair Care'
        },
        discount: 'From 99+5% Off', 
        tagline: 'Shampoos, Face Washes & More' 
    },
    { 
        id: 'product3',
        url: 'https://rukminim1.flixcart.com/flap/200/200/image/74bc985c62f19245.jpeg?q=70', 
        title: {
            shortTitle: 'Skybags & Safari'
        }, 
        discount: 'Upto 70% Off', 
        tagline: 'Deal of the Day' 
    },
    { 
        id: 'product4',
        url: 'https://rukminim1.flixcart.com/image/300/300/kll7bm80/smartwatch/c/1/n/43-mo-sw-sense-500-android-ios-molife-original-imagyzyycnpujyjh.jpeg?q=70', 
        detailUrl: 'https://rukminim1.flixcart.com/image/416/416/kll7bm80/smartwatch/c/1/n/43-mo-sw-sense-500-android-ios-molife-original-imagyzyycnpujyjh.jpeg?q=70',
        title: {
            shortTitle: 'Smart Watches',
            longTitle: 'Molife Sense 500 Smartwatch  (Black Strap, Freesize)',
        }, 
        price: {
            mrp: 6999,
            cost: 4049,
            discount: '42%'
        },
        description: 'The Molife Sense 500, a brilliant smartwatch with a beautiful large display. Say hello to the infinity 1.7-inch display with 2.5D curved edges. Thanks to seamless Bluetooth 5.0 connectivity, you wont have to keep waiting. Bring a change to your outfit every day with changeable straps. A splash of color every day keeps the boredom away.',
        discount: 'Grab Now', 
        tagline: 'Best Seller' 
    },
    { 
        id: 'product5',
        url: 'https://rukminim1.flixcart.com/flap/150/150/image/b616a7aa607d3be0.jpg?q=70', 
        title: {
            shortTitle: 'Sports & Fitness Essentials'
        }, 
        discount: 'Upto 80% Off', 
        tagline: 'Ab Exerciser, Yoga & more' 
    }
];

export const furnitureData = [
    { 
        url: 'https://rukminim1.flixcart.com/image/300/300/ke7ff680/hammock-swing/j/f/u/q3-jkaf-y3l0-furniture-kart-original-imafux96kpy7grch.jpeg?q=70', 
        title: {
            shortTitle: 'Hammock And Swings'
        }, 
        discount: 'From ₹199', 
        tagline: 'Trendy Collection' 
    },
    { 
        url: 'https://rukminim1.flixcart.com/image/300/300/bean-bag/h/v/b/f8-the-furniture-store-xxxl-original-imae65d3wg7qzpkn.jpeg?q=70', 
        title: {
            shortTitle: 'Bean Bag Covers'
        }, 
        discount: 'Min 80% Off', 
        tagline: 'XL, XXL & More' 
    },
    { 
        url: 'https://rukminim1.flixcart.com/image/300/300/jlcmavk0/aquarium-tank/s/4/5/usb-desktop-aquarium-with-running-water-calendar-temperature-and-original-imaf8hv4nkv55gx8.jpeg?q=70', 
        title: {
            shortTitle: 'Aquarium Tank'
        }, 
        discount: 'From ₹299', 
        tagline: 'Flat, Round, Cube & More' 
    },
    { 
        url: 'https://rukminim1.flixcart.com/image/300/300/jffpoy80/office-study-chair/v/v/z/pp-am-5001cb-apex-original-imaf3u8rbr5cdycv.jpeg?q=70', 
        title: {
            shortTitle: 'Office & Study Chairs'
        }, 
        discount: 'Min 50% Off', 
        tagline: 'Fabric & Leatherette' 
    },
    { 
        url: 'https://rukminim1.flixcart.com/image/300/300/jvcp9jk0/recliner/z/w/x/brown-top-grain-leather-sf7018011-1-royaloak-original-imafg9s9hh9vzpf3.jpeg?q=70', 
        title: {
            shortTitle: 'Recliner'
        }, 
        discount: 'From ₹4999', 
        tagline: 'Bantia, RoyalOak & More' 
    },
    { 
        url: 'https://rukminim1.flixcart.com/image/300/300/jlqwpe80-1/tv-entertainment-unit/d/t/f/particle-board-holland-tv-unit-black-forzza-black-original-imaf8t5ybywcdtys.jpeg?q=70', 
        title: {
            shortTitle: 'Tv Units'
        }, 
        discount: 'From ₹2100', 
        tagline: 'Forzza, Zuari & more' 
    },
    { 
        url: 'https://rukminim1.flixcart.com/image/300/300/inflatable-sofa/6/j/s/wsb031a-velvet-wds-original-imaeaphzbkgrz3xp.jpeg?q=70', 
        title: {
            shortTitle: 'Inflatable Sofas'
        }, 
        discount: 'Min 50% Off', 
        tagline: 'Furn Central & more' 
    },
];
</file>

<file path="client/src/context/ContextProvider.jsx">
import { createContext, useState, useEffect } from 'react';

export const LoginContext = createContext(null);

const ContextProvider = ({ children }) => {
  const [account, setAccount] = useState(null); // Start as null

  // UPDATED: Load from localStorage on mount with error handling
  useEffect(() => {
    const storedUser = localStorage.getItem('user');
    if (storedUser) {
      try {
        const parsedUser = JSON.parse(storedUser); // Expecting a JSON object
        setAccount(parsedUser.username); // Extract username
        console.log('Restored user from localStorage:', parsedUser.username); // Debug log
      } catch (error) {
        console.error('Error parsing stored user:', error);
        localStorage.removeItem('user'); // Clear invalid data
        setAccount(null);
      }
    }
  }, []);

  // Expose a logout function to clear storage
  const logout = () => {
    localStorage.removeItem('token');
    localStorage.removeItem('user');
    setAccount(null);
  };

  return (
    <LoginContext.Provider value={{ account, setAccount, logout }}>
      {children}
    </LoginContext.Provider>
  );
};

export default ContextProvider;
</file>

<file path="client/src/razorpay/loadPayment.js">
import axios from 'axios';
const url = 'http://localhost:8000';

export const loadRazorpay=(price)=> {
    const orderAmount=price+"00";
    const script = document.createElement('script');
    script.src = 'https://checkout.razorpay.com/v1/checkout.js';
    script.onerror = () => {
      alert('Razorpay SDK failed to load. Are you online?');
    };
    script.onload = async () => {
      try {
        const result = await axios.post(`${url}/create-order`, {
          amount: orderAmount,
        });
        const { id: order_id, currency } = result.data;
        const {
          data: { key: razorpayKey },
        } = await axios.get(`${url}/get-razorpay-key`);
 
        const options = {
          key: razorpayKey,
          amount: orderAmount.toString(),
          currency: currency,
          name: 'example name',
          description: 'example transaction',
          order_id: order_id,
          handler: async function (response) {
            const result = await axios.post(`${url}/pay-order`, {
              amount: orderAmount,
              razorpayPaymentId: response.razorpay_payment_id,
              razorpayOrderId: response.razorpay_order_id,
              razorpaySignature: response.razorpay_signature,
            });
            //console.log(response);
            alert(result.data.msg);
            //fetchOrders();
          },
          prefill: {
            name: 'example name',
            email: 'email@example.com',
            contact: '111111',
          },
          notes: {
            address: 'example address',
          },
          theme: {
            color: '#80c0f0',
          },
        };  
        const paymentObject = new window.Razorpay(options);
        paymentObject.open();
      } catch (err) {
        alert(err);
      }
    };
    document.body.appendChild(script);
  }
</file>

<file path="client/src/razorpay/razorpay.js">
import axios from 'axios';
import React, { useEffect, useState } from 'react';

function Razorpay() {
  const [loading, setLoading] = useState(false);
  const [orderAmount, setOrderAmount] = useState(0);
  const [orders, setOrders] = useState([]);

  const url = 'http://localhost:8000';

  async function fetchOrders() {
    const { data } = await axios.get(`${url}/pay-res`);
    setOrders(data);
    console.log(orders);
  }
  useEffect(() => {
    fetchOrders();
  }, []);

  const loadRazorpay=()=> {
    const script = document.createElement('script');
    script.src = 'https://checkout.razorpay.com/v1/checkout.js';
    script.onerror = () => {
      alert('Razorpay SDK failed to load. Are you online?');
    };
    script.onload = async () => {
      try {
        setLoading(true);
        const result = await axios.post(`${url}/create-order`, {
          amount: orderAmount,
        });
        const { amount, id: order_id, currency } = result.data;
        const {
          data: { key: razorpayKey },
        } = await axios.get(`${url}/get-razorpay-key`);
 
        const options = {
          key: razorpayKey,
          amount: orderAmount.toString(),
          currency: currency,
          name: 'example name',
          description: 'example transaction',
          order_id: order_id,
          handler: async function (response) {
            const result = await axios.post(`${url}/pay-order`, {
              amount: orderAmount,
              razorpayPaymentId: response.razorpay_payment_id,
              razorpayOrderId: response.razorpay_order_id,
              razorpaySignature: response.razorpay_signature,
            });
            console.log(response);
            alert(result.data.msg);
            fetchOrders();
          },
          prefill: {
            name: 'example name',
            email: 'email@example.com',
            contact: '111111',
          },
          notes: {
            address: 'example address',
          },
          theme: {
            color: '#80c0f0',
          },
        };

        setLoading(false);
        const paymentObject = new window.Razorpay(options);
        paymentObject.open();
      } catch (err) {
        alert(err);
        setLoading(false);
      }
    };
    document.body.appendChild(script);
  }

  return (
    <div className="App">
      <h1> Razorpay Example: Node & React</h1>
      <hr />
      <div>
        <h2> Pay Order</h2>
        <label>
          Amount:{' '}
          <input
            placeholder="INR"
            type="number"
            value={orderAmount}
            onChange={(e) => setOrderAmount(e.target.value)}
          ></input>
        </label>

        <button disabled={loading} onClick={loadRazorpay}>
          Razorpay
        </button>
        {loading && <div>Loading...</div>}
      </div>
      <div className="list-orders">
        <h2>List Orders</h2>
        <table>
          <thead>
            <tr>
              <th>ID</th>
              <th>AMOUNT</th>
              <th>ISPAID</th>
              <th>RAZORPAY</th>
            </tr>
          </thead>
          <tbody>
            {orders.map((x) => (
              <tr key={x._id}>
                <td>{x._id}</td>
                <td>{x.amount / 100}</td>
                <td>{x.isPaid ? 'YES' : 'NO'}</td>
                {/* <td>{x.razorpay.paymentId}</td> */}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
}

export default Razorpay;
</file>

<file path="client/src/reducers/reducer.js">
export const initialState = {
    addToCart: {}
}


export const reducer = (state, action) => {
    switch (action.type) {
        case 'addToCart' : 
            let a =  { ...state, [action.type]: action.value };
            console.log(a)
            return a;
        case 'reset': 
            return initialState;
        default: 
            return state;
    }
}
</file>

<file path="client/src/redux/actions/cartActions.js">
import * as actionTypes from '../constants/cartConstants';
import axios from 'axios';

export const addToCart = (id, quantity) => async (dispatch, getState) => {
    try { 
        const { data } = await axios.get(`http://localhost:8000/product/${id}`);

        dispatch({ type: actionTypes.ADD_TO_CART, payload: { ...data, quantity } });

        localStorage.setItem('cart', JSON.stringify(getState().cart.cartItems))
    } catch (error) {
        console.log('Error while calling cart API');
    }
};

export const removeFromCart = (id) => (dispatch, getState) => {
    console.log(id);
    dispatch({
        type: actionTypes.REMOVE_FROM_CART,
        payload: id
    })

    localStorage.setItem('cart', JSON.stringify(getState().cart.cartItems));
};
</file>

<file path="client/src/redux/actions/productActions.js">
import * as actionTypes from '../constants/productConstant';
import axios from 'axios';

export const getProducts = () => async (dispatch) => {
    try {
        console.log('Fetching products...')
        const { data } = await axios.get(`http://localhost:8000/products`);
        
        // Add id field to each product for consistency
        const productsWithId = data.map(product => ({
            ...product,
            id: product.id || product._id // Use existing id or fallback to _id
        }));
        
        dispatch({ type: actionTypes.GET_PRODUCTS_SUCCESS, payload: productsWithId });
    } catch (error) {
        dispatch({ type: actionTypes.GET_PRODUCTS_FAIL, payload: error.response });
    }
};

export const getProductDetails = (id) => async (dispatch) => {
    try {
        dispatch({ type: actionTypes.GET_PRODUCT_DETAILS_REQUEST });
        console.log('Fetching product details for ID:', id);
        
        const { data } = await axios.get(`http://localhost:8000/product/${id}`);
        console.log('Product details response:', data);

        if (data) {
            // Ensure the product has an id field
            const productWithId = {
                ...data,
                id: data.id || data._id
            };
            dispatch({ type: actionTypes.GET_PRODUCT_DETAILS_SUCCESS, payload: productWithId });
        } else {
            dispatch({ type: actionTypes.GET_PRODUCT_DETAILS_FAIL, payload: 'Product not found' });
        }
    } catch (error) {
        console.error('Error fetching product details:', error);
        dispatch({ type: actionTypes.GET_PRODUCT_DETAILS_FAIL, payload: error.response?.data || error.message});
    }
};
</file>

<file path="client/src/redux/constants/cartConstants.js">
export const ADD_TO_CART = "addToCart"
export const REMOVE_FROM_CART = "removeFromCart"
export const CART_RESET = "cartReset"
</file>

<file path="client/src/redux/constants/productConstant.js">
export const GET_PRODUCTS_SUCCESS = 'getProductsSuccess'
export const GET_PRODUCTS_FAIL = 'getProductsFail'


export const GET_PRODUCT_DETAILS_REQUEST = 'getProductDetailsRequest'
export const GET_PRODUCT_DETAILS_SUCCESS = 'getProductDetailSuccess'
export const GET_PRODUCT_DETAILS_FAIL = 'getProductDetailFail'
export const GET_PRODUCT_DETAILS_RESET = 'getProductDetailReset'
</file>

<file path="client/src/redux/reducers/cartReducer.js">
import * as actionTypes from '../constants/cartConstants';

export const cartReducer = (state = { cartItems: []}, action) => {
    console.log('Heyya',    action.type);
    switch(action.type) {
        case actionTypes.ADD_TO_CART:
            const item = action.payload;

            const existItem = state.cartItems.find(product => product.id === item.id);
            console.log(existItem)
            console.log(item);
            console.log(state.cartItems)

           if(existItem){
            return {
                ...state, 
                // FIX: Compare by item ID (x.id === item.id)
                cartItems: state.cartItems.map(x => x.id === item.id ? item : x)
            }
            } else {
                let a =  { ...state, cartItems: [...state.cartItems, item]}
                console.log(a)
                return a;
            }
        case actionTypes.REMOVE_FROM_CART:
            console.log(state.cartItems)
            console.log(action.payload);
            let s =  {
                ...state, cartItems: state.cartItems.filter(product => product.id !== action.payload)
            }
            console.log(s);
            return s;

        default:
            return state;
    }
}
</file>

<file path="client/src/redux/reducers/productReducer.js">
import * as actionTypes from '../constants/productConstant';


export const getProductReducer = (state = {products: []}, action) => {
    switch(action.type) {
        case actionTypes.GET_PRODUCTS_SUCCESS:
            return { products: action.payload }
        case actionTypes.GET_PRODUCTS_FAIL:
            return { error: action.payload }
        default:
            return state
    }
};

export const getProductDetailsReducer = (state = { product: {}}, action) => {
    
    console.log('Hi', action.type)
    switch(action.type){
        case actionTypes.GET_PRODUCT_DETAILS_REQUEST:
            return { loading: true }
        case actionTypes.GET_PRODUCT_DETAILS_SUCCESS:
            return { loading: false, product: action.payload }
        case actionTypes.GET_PRODUCT_DETAILS_FAIL:
            return {
                loading: false,
                error: action.payload
            }
        case actionTypes.GET_PRODUCT_DETAILS_RESET: 
            return {
                product: {}
            }
        default:
            return state
    }
}
</file>

<file path="client/src/redux/store.js">
import { createStore, applyMiddleware, combineReducers } from 'redux';
import thunk from 'redux-thunk';
import { composeWithDevTools } from 'redux-devtools-extension';

import { cartReducer } from './reducers/cartReducer';
import { getProductDetailsReducer, getProductReducer } from './reducers/productReducer';

const reducer = combineReducers({
    cart: cartReducer,
    getProducts: getProductReducer,
    getProductDetails: getProductDetailsReducer
})


const middleware = [thunk];

const store = createStore(
    reducer, 
    composeWithDevTools(applyMiddleware(...middleware))
);

export default store;
</file>

<file path="client/src/service/api.js">
import axios from 'axios';

const url = 'http://localhost:8000';

export const authenticateLogin = async (user) => {
    try {
        return  await axios.post(`${url}/login`, user) 
    } catch (error) {
        console.log('error while calling login API: ', error);
    }
}

export const authenticateSignup = async (user) => {
    try {
        return await axios.post(`${url}/signup`, user)
    } catch (error) {
        console.log('error while calling Signup API: ', error);
    }
}

export const getProductById = async (id) => {
    try {
        return await axios.get(`${url}/product/${id}`);
    } catch (error) {
        console.log('Error while getting product by id response', error);
    }
}

export  const payUsingPaytm = async (data) => {
    try {
        console.log('payment api');
        let response = await axios.post(`${url}/payment`, data);
        console.log(response.data);
        return response.data;
    } catch (error) {
        console.log('error', error);
    }
}
</file>

<file path="client/src/templates/TemplateProvider.js">
import React from 'react';
import { CssBaseline } from "@material-ui/core";
import { ThemeProvider, createMuiTheme } from "@material-ui/core/styles";

const TemplateContext = React.createContext(null);

export const TemplateProvider = ({ children }) => {
    const theme = createMuiTheme({
        overrides: {
            MuiDialog: {
                paperWidthSm: {
                    maxWidth: 'unset'
                }
            },
            MuiDialogContent: {
                root: {
                    padding: 0,
                    '&:first-child': {
                        paddingTop: 0
                    }
                }
            },
            MuiTableCell: {
                root: {
                    borderBottom: 0
                }
            }
        }
    });

    return (
        <TemplateContext.Provider>
            <ThemeProvider theme={theme}>
                <CssBaseline />
                {children}
            </ThemeProvider>
        </TemplateContext.Provider>
    );
}

export default TemplateProvider;
</file>

<file path="client/src/App.css">
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
</file>

<file path="client/src/App.js">
import React, { Suspense, lazy } from 'react';
import { BrowserRouter, Switch, Route } from 'react-router-dom';
import Header from './Components/Header/Header';
import TemplateProvider from './templates/TemplateProvider';
import ContextProvider from './context/ContextProvider';
import { Box, Typography } from '@material-ui/core';
import { Provider } from 'react-redux';
import store from './redux/store';

// Lazy load all major components
const Home = lazy(() => import('./Components/Home'));
const Cart = lazy(() => import('./Components/Cart/Cart'));
const DetailView = lazy(() => import('./Components/ItemDetails/DetailView'));
const SearchResultsPage = lazy(() => import('./Components/SearchResults/SearchResultsPage'));
const NotFound = lazy(() => import('./Components/NotFound'));

function App() {
  return (
    <TemplateProvider>
      <Provider store={store}>
        <ContextProvider>
          <BrowserRouter>
            <Header />
            <Box style={{ marginTop: 54 }}>
              <Suspense fallback={<Typography>Loading...</Typography>}>
                <Switch>
                  <Route exact path="/" component={Home} />
                  <Route path="/cart" component={Cart} />
                  <Route path="/product/:id" component={DetailView} />
                  <Route path="/search" component={SearchResultsPage} />
                  <Route component={NotFound} />  {/* Catch-all for 404 */}
                </Switch>
              </Suspense>
            </Box>
          </BrowserRouter>
        </ContextProvider>
      </Provider>
    </TemplateProvider>
  );
}

export default App;
</file>

<file path="client/src/index.css">
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}
</file>

<file path="client/src/index.js">
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import { Provider } from 'react-redux';
import store from './redux/store';

ReactDOM.render(
  <Provider store={store} >
    <React.StrictMode>
      <App />
    </React.StrictMode>
  </Provider>,
  document.getElementById('root')
);
</file>

<file path="client/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*
</file>

<file path="client/package.json">
{
  "name": "client",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@google-pay/button-react": "^2.3.0",
    "@material-ui/core": "^4.11.4",
    "@material-ui/icons": "^4.11.2",
    "@testing-library/jest-dom": "^5.12.0",
    "@testing-library/react": "^11.2.6",
    "@testing-library/user-event": "^12.8.3",
    "axios": "^0.21.4",
    "clsx": "^1.1.1",
    "dompurify": "^3.2.6",
    "react": "^17.0.2",
    "react-countdown": "^2.3.2",
    "react-dom": "^17.0.2",
    "react-material-ui-carousel": "^2.2.6",
    "react-multi-carousel": "^2.6.2",
    "react-redux": "^7.2.4",
    "react-router-dom": "^5.2.0",
    "react-scripts": "4.0.3",
    "redux": "^4.1.0",
    "redux-devtools-extension": "^2.13.9",
    "redux-thunk": "^2.3.0",
    "web-vitals": "^1.1.2"
  },
  "scripts": {
    "start": "NODE_OPTIONS=--openssl-legacy-provider react-scripts start",
    "build": "NODE_OPTIONS=--openssl-legacy-provider react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "analyze": "npm run build -- --stats"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
</file>

<file path="server/constants/abbreviations.js">
// server/constants/abbreviations.js
export const abbreviationMap = {
  // Electronics & Appliances
  'tv': 'Televisions',
  'television': 'Televisions',
  'ac': 'Air Conditioners',
  'airconditioner': 'Air Conditioners',
  'aircon': 'Air Conditioners',
  'wm': 'Washing Machines',
  'washingmachine': 'Washing Machines',
  'mwo': 'Microwave Ovens',
  'microwave': 'Microwave Ovens',
  'mjg': 'Mixer Juicer Grinder',
  'otg': 'Oven Toaster Grills',
  'ro': 'Water purifiers',
  'uv': 'Water purifiers',
  'uf': 'Water purifiers',
  'hdd': 'External HDD',
  'ssd': 'External HDD',
  
  // Cameras
  'dslr': 'DSLR & Mirrorless',
  'mirrorless': 'DSLR & Mirrorless',
  'camera': 'DSLR & Mirrorless',
  
  // Networking
  'wifi': 'Routers',
  'router': 'Routers',
  
  // Gaming
  'rc': 'Remote Control Toys',
  'remotecontrol': 'Remote Control Toys',
  
  // Beauty & Care
  'spf': 'Body and Face Care',
  'skincare': 'Body and Face Care',
  'bodycare': 'Body and Face Care',
  
  // Audio
  'tws': 'True Wireless',
  'earbuds': 'True Wireless',
  'headphones': 'True Wireless',
  
  // Sports & Fitness
  'mtb': 'Cycles',
  'bicycle': 'Cycles',
  'bike': 'Cycles',
  
  // Fragrance
  'perfume': 'Perfume',
  'cologne': 'Perfume',
  'fragrance': 'Perfume',
  
  // Supplements
  'protein': 'Protein Supplement',
  'whey': 'Protein Supplement',
  
  // Automotive
  'car': 'Automotive Accessories',
  'auto': 'Automotive Accessories',
  
  // Lighting
  'led': 'Decor lighting & Accessories',
  'bulb': 'Decor lighting & Accessories',
  'light': 'Decor lighting & Accessories',
  
  // Technology
  'ai': 'Automation & Robotics',
  'ml': 'Automation & Robotics',
  'iot': 'Automation & Robotics',
  'smart': 'Automation & Robotics'
};

// Function to expand query with abbreviations
export function expandQueryWithAbbreviations(query) {
  const normalizedQuery = query.toLowerCase().trim();
  
  // Check for exact match first
  if (abbreviationMap[normalizedQuery]) {
    return abbreviationMap[normalizedQuery];
  }
  
  // Check for partial matches in multi-word queries
  const words = normalizedQuery.split(/\s+/);
  const expandedWords = words.map(word => {
    return abbreviationMap[word] || word;
  });
  
  // If any word was expanded, return the expanded version
  if (expandedWords.some((word, index) => word !== words[index])) {
    return expandedWords.join(' ');
  }
  
  return query; // Return original if no abbreviation found
}
</file>

<file path="server/constants/product.js">
export const products = [
    { 
        id: 'product1',
        url: 'https://rukminim1.flixcart.com/image/150/150/kapoo7k0/electric-kettle/p/6/s/pigeon-favourite-original-imafs7xhj5uwgrh4.jpeg?q=70', 
        detailUrl: 'https://rukminim1.flixcart.com/image/416/416/kapoo7k0/electric-kettle/p/6/s/pigeon-favourite-original-imafs7xhj5uwgrh4.jpeg?q=70',
        title: {
            shortTitle: 'Home & Kitchen',
            longTitle: 'Pigeon FAVOURITE Electric Kettle  (1.5 L, Silver, Black)'
        }, 
        price: {
            mrp: 1195,
            cost: 625,
            discount: '47%'
        },
        quantity: 1,
        description: 'This electric kettle from Pigeon will soon become a travelers best friend, a hostelite saviour and an answer to all the midnight cravings. With this handy appliance, you can boil water and use it to make instant noodles, packet soup, coffee and green tea.',
        discount: 'Extra 10% Off', 
        tagline: 'Deal of the day' 
    },
    { 
        id: 'product2',
        url: 'https://rukminim1.flixcart.com/image/416/416/kl6wx3k0/sandwich-maker/8/r/d/sandwich-01-flipkart-smartbuy-original-imagydds4zthxt8z.jpeg?q=70', 
        detailUrl: 'https://rukminim1.flixcart.com/image/416/416/kl6wx3k0/sandwich-maker/8/r/d/sandwich-01-flipkart-smartbuy-original-imagydds4zthxt8z.jpeg?q=70',
        title: {
            shortTitle: 'Sandwich Makers',
            longTitle: 'Flipkart SmartBuy Sandwich 01 Grill  (Black)'
        },
        price: {
            mrp: 1499,
            cost: 899,
            discount: '40%'
        },
        quantity: 1,
        description: 'This non-stick sandwich toaster .easy to use and very handy. Directly hold over flame to make tasty toasts and toasted sandwiches. Specially designed by keeping your needs in mind, the sandwich maker makes whatever youre doing simpler, smarter and better',
        discount: 'From 99+5% Off', 
        tagline: 'Pestige, Nova & more' 
    },
    { 
        id: 'product3',
        url: 'https://rukminim1.flixcart.com/image/150/150/kohigsw0/resistance-tube/c/s/e/new-adjustable-single-resistance-tube-multicolor-na-ajro-deal-original-imag2xg88mhmwxz5.jpeg?q=70', 
        detailUrl: 'https://rukminim1.flixcart.com/image/416/416/kohigsw0/resistance-tube/c/s/e/new-adjustable-single-resistance-tube-multicolor-na-ajro-deal-original-imag2xg88mhmwxz5.jpeg?q=70', 
        title: {
            shortTitle: 'Fitness Gear',
            longTitle: 'AJRO DEAL New Adjustable Single Resistance Tube (Multicolor) Resistance Tube  (Multicolor)'
        }, 
        price: {
            mrp: 499,
            cost: 166,
            discount: '66%'
        },
        quantity: 1,
        description: 'This unique product can tone your back muscles, reduce belly fat, improve blood circulation and also improves your body posture. It increases the stamina, energy and vitality of the body. The elastic resistance of the rubber training rope can be used to train and exercise in whichever way you want, according to your physical needs.',
        discount: 'Upto 70% Off', 
        tagline: 'Deal of the Day' 
    },
    { 
        id: 'product4',
        url: 'https://rukminim1.flixcart.com/image/300/300/kll7bm80/smartwatch/c/1/n/43-mo-sw-sense-500-android-ios-molife-original-imagyzyycnpujyjh.jpeg?q=70', 
        detailUrl: 'https://rukminim1.flixcart.com/image/416/416/kll7bm80/smartwatch/c/1/n/43-mo-sw-sense-500-android-ios-molife-original-imagyzyycnpujyjh.jpeg?q=70',
        title: {
            shortTitle: 'Smart Watches',
            longTitle: 'Molife Sense 500 Smartwatch  (Black Strap, Freesize)',
        }, 
        price: {
            mrp: 6999,
            cost: 4049,
            discount: '42%'
        },
        quantity: 1,
        description: 'The Molife Sense 500, a brilliant smartwatch with a beautiful large display. Say hello to the infinity 1.7-inch display with 2.5D curved edges. Thanks to seamless Bluetooth 5.0 connectivity, you wont have to keep waiting. Bring a change to your outfit every day with changeable straps. A splash of color every day keeps the boredom away.',
        discount: 'Grab Now', 
        tagline: 'Best Seller' 
    },
    { 
        id: 'product5',
        url: 'https://rukminim1.flixcart.com/image/416/416/k3uhhu80/hair-dryer/n/m/t/nova-2800-w-professional-nhp-8220-original-imafmvwfhmzsxdrw.jpeg?q=70',
        detailUrl: 'https://rukminim1.flixcart.com/image/416/416/k3uhhu80/hair-dryer/n/m/t/nova-2800-w-professional-nhp-8220-original-imafmvwfhmzsxdrw.jpeg?q=70', 
        title: {
            shortTitle: 'Trimmers, Dryers & more',
            longTitle: 'Nova Professional NHP 8220 Hair Dryer  (1800 W, Multicolor)'
        }, 
        price: {
            mrp: 1899,
            cost: 1124,
            discount: '40%'
        },
        quantity: 1,
        description: '',
        discount: 'From ₹499', 
        tagline: 'Kubra, Nova & more' 
    },
    { 
        id: 'product6',
        url: 'https://rukminim1.flixcart.com/image/150/150/kk01pjk0/fan/d/d/l/tiktik-quiet-portable-table-fan-zigma-original-imafzg7ftzuckpad.jpeg?q=70',
        detailUrl: 'https://rukminim1.flixcart.com/image/416/416/kk01pjk0/fan/d/d/l/tiktik-quiet-portable-table-fan-zigma-original-imafzg7ftzuckpad.jpeg?q=70', 
        title: {
            shortTitle: 'Table Fans',
            longTitle: 'Portable 300 mm Ultra High Speed 3 Blade Table Fan  (Black, Pack of 1)'
        }, 
        price: {
            mrp: 2250,
            cost: 1199,
            discount: '46%'
        },
        quantity: 1,
        description: 'Table Fan. Perfect size fan for use on a table, desk or in an RV. Whisper quiet, powerful airflow and reliable operation in a compact 6" size. Two adjustable speeds to customize airflow: high or low settings. Tough break-resistant ABS plastic blades. ',
        discount: 'Minimum 40% Off', 
        tagline: 'Top Selling' 
    },
    { 
        id: 'product7',
        url: 'https://rukminim1.flixcart.com/image/150/150/kcgk1ow0/headphone/n/u/a/235v2-fast-charging-boat-original-imaftk6us4af7bca.jpeg?q=70',
        detailUrl: 'https://rukminim1.flixcart.com/image/416/416/kcgk1ow0/headphone/n/u/a/235v2-fast-charging-boat-original-imaftk6us4af7bca.jpeg?q=70', 
        title: {
            shortTitle: 'Headphones',
            longTitle: 'boAt Rockerz 235v2 with ASAP charging Version 5.0 Bluetooth Headset '
        }, 
        price: {
            mrp: 2990,
            cost: 1199,
            discount: '59%'
        },
        quantity: 1,
        description: 'Let music brighten up your mood anytime, anywhere with the boAt 235v2 Fast Charging Bluetooth Headset. This Bluetooth headset features a Call Vibration Alert, a Fast Charging Technology, and Easy Access Controls to listen to and manage your favorite music with ease.',
        discount: 'Minimum 50% Off', 
        tagline: 'Grab Now!' 
    }
];
</file>

<file path="server/controller/cart-controller.js">
import Cart from '../model/cartSchema.js';


export const addItemInCart = (request, response) => {
    return response.json("Hello");
}
</file>

<file path="server/controller/categoryController.js">
import Product from '../model/productSchema.js';

// Get all unique categories
export const getCategories = async (req, res) => {
  const categories = await Product.distinct('category');
  res.json(categories);
};

// Get all unique subcategories for a category
export const getSubcategories = async (req, res) => {
  const subcategories = await Product.distinct('subcategory', { category: req.params.category });
  res.json(subcategories);
};

// Recommend top N products from a category/subcategory (could sort by rating/popularity)
export const getCategoryRecommendations = async (req, res) => {
  const { category } = req.params;
  const products = await Product.find({ category }).sort({ product_rating: -1 }).limit(8);
  res.json(products);
};
</file>

<file path="server/controller/payment-controller.js">
import Order from "../model/orderSchema.js";
import Razorpay from "razorpay";
import { updateRecentPurchases } from '../utils/userHistory.js';


export const createOrder = (request, response) => {
  try {
    const instance = (instance = new Razorpay({
      key_id: process.env.RAZORPAY_KEY_ID,
      key_secret: process.env.RAZORPAY_KEY_SECRET,
    }));
   console.log(request.body);
    const options = {
      amount: request.body.price,
      currency: "INR",
    };
    const order = instance.create(options);
    if (!order) response.send("Some error occured");
    response.send(order);
  } catch (error) {
    response.send(error);
  }
};

export const payOrder = async (request, response) => {
  // console.log("triiggerd payOder");
  // console.log(request.body);
  try {
    const { amount, razorpayPaymentId, razorpayOrderId, razorpaySignature } =
      request.body;
    const newOrder = Order.create({
      isPaid: true,
      amount: amount,
      razorpay: {
        order_id: razorpayOrderId,
        payment_id: razorpayPaymentId,
        signature: razorpaySignature,
      },
    });
    await response.send({msg:"payment was successfull"});
  } catch (error) {
    response.send(error);
  }
};

export const paymentResponse= async(request,response)=>{
 const orders=await Order.find();
 console.log(orders);
 response.send(orders);
}
</file>

<file path="server/controller/product-controller.js">
import Product from '../model/productSchema.js';
import { redisClient } from '../database/redis.js';
import mongoose from 'mongoose';

const CACHE_EXPIRATION_SECONDS = 3600;

export const getProducts = async (request, response) => {
  try {
    const { page = 1, limit = 20 } = request.query;  // Add pagination params
    const skip = (page - 1) * limit;

    const cachedProducts = await redisClient.get(`products:page:${page}`);
    if (cachedProducts) {
      return response.json(JSON.parse(cachedProducts));
    }

    const products = await Product.find({}).skip(skip).limit(parseInt(limit));  // Paginate
    await redisClient.setEx(`products:page:${page}`, 3600, JSON.stringify(products));  // Cache per page
    response.json(products);
  } catch (error) {
    response.status(500).json({ message: error.message });
  }
};

// Similarly for getProductById:
export const getProductById = async (request, response) => {
  try {
    const productId = request.params.id;
    const cachedProduct = await redisClient.get(`product:${productId}`);
    if (cachedProduct) {
      return response.json(JSON.parse(cachedProduct));
    }

    let product = await Product.findById(productId) || await Product.findOne({ pid: productId });
    if (!product) return response.status(404).json({ message: 'Product not found' });

    await redisClient.setEx(`product:${productId}`, 3600, JSON.stringify(product));  // Cache
    response.json(product);
  } catch (error) {
    response.status(500).json({ message: error.message });
  }
};
</file>

<file path="server/controller/user-controller.js">
import bcrypt from 'bcrypt';
import User from '../model/userSchema.js';
import jwt from 'jsonwebtoken';

export const userSignUp = async (req, res) => {
    try {
        const { firstname, lastname, username, email, password, phone } = req.body;
        
        // Check if user already exists
        const existingUser = await User.findOne({ 
            $or: [{ username }, { email }] 
        });
        
        if (existingUser) {
            return res.status(409).json({ message: 'User already exists' });
        }

        // Hash the password
        const hashedPassword = await bcrypt.hash(password, 10);
        
        const newUser = new User({
            firstname,
            lastname,
            username,
            email,
            phone,
            password: hashedPassword
        });

        await newUser.save();

        // Generate JWT token
        const token = jwt.sign(
            { userId: newUser._id, username: newUser.username },
            process.env.JWT_SECRET || 'fallback_secret',
            { expiresIn: '7d' }
        );

        res.status(200).json({ 
            message: `${newUser.firstname} has been successfully registered`,
            token,
            user: {
                id: newUser._id,
                firstname: newUser.firstname,
                lastname: newUser.lastname,
                username: newUser.username,
                email: newUser.email
            }
        });
    } catch (error) {
        console.error('Signup error:', error);
        res.status(500).json({ message: error.message });
    }
};

export const userLogIn = async (req, res) => {
    try {
        // Frontend sends 'email' field, not 'emailOrUsername'
        const { email, password } = req.body;
        
        // Find user by email or username
        const user = await User.findOne({
            $or: [{ email }, { username: email }]
        });

        if (!user) {
            return res.status(401).json({ message: 'User not found' });
        }

        const isMatch = await bcrypt.compare(password, user.password);
        if (!isMatch) {
            return res.status(401).json({ message: 'Incorrect password' });
        }

        const token = jwt.sign(
            { userId: user._id, username: user.username },
            process.env.JWT_SECRET || 'fallback_secret',
            { expiresIn: '7d' }
        );

        res.json({
            token,
            user: {
                id: user._id,
                firstname: user.firstname,
                lastname: user.lastname,
                username: user.username,
                email: user.email
            }
        });
    } catch (err) {
        console.error('Login error:', err);
        res.status(500).json({ message: 'Error: ' + err.message });
    }
};
</file>

<file path="server/database/redis.js">
import { createClient } from 'redis';

export const redisClient = createClient();
redisClient.on('error', (err) => console.log('Redis Client Error', err));
await redisClient.connect();
console.log('Connected to Redis.');

export async function getUserProfile(userId) {
    try {
        const profileJSON = await redisClient.get(`user:${userId}`);
        return profileJSON ? JSON.parse(profileJSON) : { clicked_products: [] };
    } catch (err) {
        return null;
    }
}

export async function updateUserProfile(userId, productId) {
    try {
        const profile = await getUserProfile(userId);
        if (profile && !profile.clicked_products.includes(productId)) {
            profile.clicked_products.push(productId);
            await redisClient.set(`user:${userId}`, JSON.stringify(profile));
            console.log(`User ${userId} profile updated with product ${productId}`);
        }
    } catch (err) {
        console.error('Error updating user profile:', err);
    }
}
</file>

<file path="server/middleware/auth.js">
import jwt from 'jsonwebtoken';

export const auth = (req, res, next) => {
  const token = req.headers['authorization'];
  if (!token) return res.status(401).json({ message: 'No token provided' });
  try {
    const decoded = jwt.verify(token.replace('Bearer ', ''), process.env.JWT_SECRET || 'yourSecret');
    req.user = decoded;
    next();
  } catch (err) {
    res.status(401).json({ message: 'Invalid token' });
  }
};
</file>

<file path="server/model/cartSchema.js">
import mongoose from 'mongoose';

const cartSchema = new mongoose.Schema({
    user: {
        username: String,
        // ref: 'user',
        // required: true 
    },
    cartItems: [
        {
            product: {
                id: String,
                // required: true,
                // ref: 'Product'
            },
            quantity: {
                type: Number,
                default: 1
            },
            price: {
                price: Number,
                // required: true
            }
        }
    ]
});

let Cart = mongoose.model('Cart', cartSchema);

export default Cart;
</file>

<file path="server/model/orderSchema.js">
import mongoose from "mongoose"

export const OrderSchema=mongoose.Schema({

    isPaid:Boolean,
    amount:Number,
    razorpay:{
        order_id:String,
        payment_id:String,
        signature:String,
    },

})

const order=mongoose.model("order",OrderSchema);

export default order;
</file>

<file path="server/model/productSchema.js">
import mongoose from 'mongoose';

const productSchema = new mongoose.Schema({
    id: String,
    pid: String,
    url: String,
    detailUrl: String,
    title: Object,
    price: Object,
    quantity: Number,
    description: String,
    discount: String,
    tagline: String,
    brand: String,          // For brand filtering
    category: String,       // For category filtering
    subcategory: String,
    rating: Number,         // For rating filtering
    specifications: String,
    product_category_tree: String, // You can keep this if you want hierarchy

});
productSchema.index({ id: 1, pid: 1, category: 1, brand: 1 });
const products = mongoose.model('product', productSchema);

export default products;
</file>

<file path="server/model/userSchema.js">
import mongoose from 'mongoose';

const userSchema = new mongoose.Schema({
    firstname: { type: String, required: true, trim: true, max: 20 },
    lastname: { type: String, required: true, trim: true, max: 20 },
    username: { type: String, required: true, trim: true, unique: true, index: true },
    email: { type: String, required: true, trim: true, unique: true, lowercase: true },
    phone: { type: String, required: true },
    password: { type: String, required: true },
    recentSearches: { type: [String], default: [] },
    recentCart: { type: [Object], default: [] },
    recentPurchases: { type: [Object], default: [] }
}, { timestamps: true });

const User = mongoose.model('User', userSchema);
export default User;
</file>

<file path="server/routes/route.js">
import express from  'express';
import { getProductById, getProducts } from '../controller/product-controller.js';
import { userSignUp, userLogIn } from '../controller/user-controller.js';
import { addItemInCart } from '../controller/cart-controller.js';
import { createOrder } from '../controller/payment-controller.js';
import { payOrder } from '../controller/payment-controller.js';
import { paymentResponse } from '../controller/payment-controller.js';
import { personalizedSearch, trackClick } from '../controller/search-controller.js';
import { getCategories, getSubcategories, getCategoryRecommendations } from '../controller/categoryController.js';
import { autosuggest } from '../controller/search-controller.js';


const router = express.Router();

//login & signup
router.post('/signup', userSignUp);
router.post('/login', userLogIn);

router.get('/products', getProducts);
router.get('/product/:id', getProductById);

router.post('/cart/add', addItemInCart);

router.get('/get-razorpay-key', (req, res) => {
    res.send({ key: process.env.RAZORPAY_KEY_ID });
  });
  router.get('/categories', getCategories);
router.get('/categories/:category/subcategories', getSubcategories);
router.get('/category-recommendations/:category', getCategoryRecommendations);
router.post("/create-order", createOrder);
router.post('/pay-order', payOrder);
router.get('/pay-res', paymentResponse);
router.get('/search', personalizedSearch);
router.post('/click', trackClick);
router.get('/autosuggest', autosuggest);


export default router;
</file>

<file path="server/utils/userHistory.js">
// utils/userHistory.js
import User from '../model/userSchema.js';

// Call this on cart change
export async function updateRecentCart(userId, cartSnapshot) {
  const user = await User.findById(userId);
  user.recentCart.unshift(cartSnapshot);
  user.recentCart = user.recentCart.slice(0, 15);
  await user.save();
}

// Call this on every search
export async function updateRecentSearches(userId, searchQuery) {
  const user = await User.findById(userId);
  // Remove duplicates
  user.recentSearches = user.recentSearches.filter(q => q !== searchQuery);
  user.recentSearches.unshift(searchQuery);
  user.recentSearches = user.recentSearches.slice(0, 15);
  await user.save();
}

// Call this after purchase completed
export async function updateRecentPurchases(userId, productObj) {
  const user = await User.findById(userId);
  user.recentPurchases.unshift(productObj);
  user.recentPurchases = user.recentPurchases.slice(0, 15);
  await user.save();
}
</file>

<file path="server/.gitignore">
/node_modules
.env
</file>

<file path="server/index.js">
import express from 'express';
import bodyParser from 'body-parser';
import cors from 'cors';
import dotenv from 'dotenv';
import Connection from './database/db.js';
import Routes from './routes/route.js';
import Product from './model/productSchema.js';
import { products } from './constants/product.js';
import { Client } from '@elastic/elasticsearch';
import compression from 'compression';

dotenv.config();

const app = express();
const PORT = 8000;

app.use(compression()); // Add this before other middleware

// --- ELASTICSEARCH & REDIS SETUP ---
export const esClient = new Client({ node: 'http://localhost:9200' });
const indexName = 'products';

async function setupElasticsearch() {
    console.log('Setting up Elasticsearch index...');
    const productsFromDB = await Product.find({});
    if (!productsFromDB || productsFromDB.length === 0) {
        console.log('No products in MongoDB to index.');
        return;
    }

    const indexExists = await esClient.indices.exists({ index: indexName });
    if (indexExists) await esClient.indices.delete({ index: indexName });

    await esClient.indices.create({
        index: indexName,
        body: {
            mappings: {
                properties: {
                    // Do NOT include _id here!
                    name: { type: 'search_as_you_type' },
                    category: { type: 'text' },
                    suggest: { type: 'completion' },
                    rating: { type: 'float' } // Added rating field for sorting
                }
            }
        }
    });

    const body = productsFromDB.flatMap(doc => {
        const source = {
            name: doc.title.longTitle,
            category: doc.title.shortTitle,
            suggest: [
                doc.title.longTitle,
                doc.title.shortTitle,
                doc.category,
                ...(doc.title.longTitle ? doc.title.longTitle.split(' ') : [])
            ].filter(Boolean),
            rating: doc.rating || 0 // Added rating to indexed data
        };
        return [{ index: { _index: indexName, _id: doc._id.toString() } }, source];
    });

    await esClient.bulk({ refresh: true, body });
    console.log(`${productsFromDB.length} products from MongoDB indexed into Elasticsearch.`);
}

const insertDefaultData = async () => {
    try {
        const count = await Product.countDocuments();
        if (count > 0) {
            console.log('Products already exist in DB. Skipping default data insertion.');
            return;
        }
        await Product.insertMany(products);
        console.log('Default product data imported successfully.');
    } catch (error) {
        console.error('Error inserting default product data:', error.message);
    }
};

Connection()
    .then(() => {
        insertDefaultData();
        setupElasticsearch().catch(console.error);
    });

// Middleware and routes
app.use(bodyParser.json({ extended: true }));
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cors());
app.use('/', Routes);

// Start the server
app.listen(PORT, () => console.log(`Server is running successfully on PORT ${PORT}`));
</file>

<file path="server/package.json">
{
  "name": "server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "nodemon server.js"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@elastic/elasticsearch": "8.14.1",
    "bcrypt": "^6.0.0",
    "body-parser": "^1.19.0",
    "compression": "^1.8.1",
    "cors": "^2.8.5",
    "csv-parser": "^3.2.0",
    "dot-env": "0.0.1",
    "dotenv": "^9.0.2",
    "express": "^4.17.1",
    "formidable": "^1.2.2",
    "https": "^1.0.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^5.12.9",
    "nodemon": "^2.0.7",
    "razorpay": "^2.0.7",
    "redis": "^4.6.15",
    "uuid": "^8.3.2"
  }
}
</file>

<file path="SRP/app/api/models.py">
# app/api/models.py
from pydantic import BaseModel
from typing import List, Dict, Any

class SearchQuery(BaseModel):
    query: str

class Product(BaseModel):
    id: str
    document: str
    metadata: Dict[str, Any]

class SearchResponse(BaseModel):
    ranked_ids: List[str]
</file>

<file path="SRP/app/api/routers.py">
# app/api/routers.py
from fastapi import APIRouter, Depends, HTTPException, status
from typing import List
from .models import SearchQuery, Product, SearchResponse
from ..services.search_service import SearchService
from ..db.chroma_manager import ChromaManager
import logging

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

router = APIRouter()

# --- Dependency Injection: Create instances once for the app's lifetime ---
try:
    logger.info("Initializing application components...")
    chroma_manager = ChromaManager()
    search_service = SearchService(chroma_manager)
    logger.info("Application components initialized successfully.")
except Exception as e:
    logger.error(f"Failed to initialize application components: {e}")
    # If core components fail, the app can't run.
    raise RuntimeError("Could not start the application due to initialization failure.") from e


def get_search_service():
    """Dependency function to get the search service instance."""
    return search_service
# --------------------------------------------------------------------------

@router.post("/search", response_model=SearchResponse)
async def search_products(request: SearchQuery, service: SearchService = Depends(get_search_service)):
    logger.info(f"Received search query: '{request.query}'")
    # `await` the asynchronous service call
    ranked_ids = await service.search(request.query)
    logger.info(f"Returning {len(ranked_ids)} ranked results.")
    return SearchResponse(ranked_ids=ranked_ids)

@router.post("/products", status_code=status.HTTP_201_CREATED)
def add_products(products: List[Product], service: SearchService = Depends(get_search_service)):
    """
    Add one or more new products to the search index.
    Embeddings are generated on the fly.
    """
    try:
        logger.info(f"Received request to add {len(products)} products.")
        # Pydantic models need to be converted to dicts
        product_dicts = [p.dict() for p in products]
        service.insert_products(product_dicts)
        return {"message": f"{len(products)} products added/updated successfully."}
    except Exception as e:
        logger.error(f"Error adding products: {e}")
        raise HTTPException(status_code=500, detail="Failed to add products to the index.")
</file>

<file path="SRP/app/db/chroma_manager.py">
# app/db/chroma_manager.py
    
import chromadb
from ..core.config import DB_PATH
import logging
from typing import List, Dict, Any, Optional

logger = logging.getLogger(__name__)

class ChromaManager:
    def __init__(self):
        self.client = chromadb.PersistentClient(path=DB_PATH)
        logger.info("ChromaDB client initialized.")

    def add_items_to_collection(
        self,
        collection_name: str,
        ids: List[str],
        documents: List[str],
        embeddings: List[List[float]],
        metadatas: Optional[List[Dict[str, Any]]] = None
    ):
        """
        Adds a batch of items to a specified collection.
        The caller is responsible for batching the data.
        """
        collection = self.client.get_or_create_collection(name=collection_name)
        
        # Directly add the provided batch. No internal looping.
        collection.add(
            ids=ids,
            documents=documents,
            embeddings=embeddings,
            metadatas=metadatas
        )
        # We don't log here to avoid spamming the console from the indexer's loop.

    async def aquery_collection(self, collection_name, query_embedding, n_results=100, where_filter=None):
        # This part remains the same
        collection = self.client.get_collection(name=collection_name)
        return collection.query(
            query_embeddings=[query_embedding.tolist()],
            n_results=n_results,
            where=where_filter
        )
</file>

<file path="SRP/app/models/model_loader.py">
# app/models/model_loader.py
import torch
from sentence_transformers import SentenceTransformer, CrossEncoder
from ..core.config import EMBEDDING_MODEL, RERANKER_MODEL

device = 'cuda' if torch.cuda.is_available() else 'cpu'
print(f"Loading models on device: {device}")

# This dictionary will hold the loaded models
models = {
    "embedding_model": SentenceTransformer(EMBEDDING_MODEL, device=device),
    "reranker_model": CrossEncoder(RERANKER_MODEL, device=device, max_length=512)
}

def get_embedding_model():
    return models["embedding_model"]

def get_reranker_model():
    return models["reranker_model"]
</file>

<file path="SRP/app/services/intent_classifier.py">
# app/services/intent_classifier.py
from ..db.chroma_manager import ChromaManager
from ..core.config import CATEGORY_COLLECTION_NAME
import logging
import numpy as np

logger = logging.getLogger(__name__)

class IntentClassifier:
    def __init__(self, chroma_manager: ChromaManager):
        logger.info("Initializing Intent Classifier...")
        self.chroma = chroma_manager
        self.collection_name = CATEGORY_COLLECTION_NAME

    async def predict_categories(self, query_embedding: np.ndarray, top_k: int = 3):
        """
        Predicts categories based on a pre-computed query embedding.
        
        Args:
            query_embedding (np.ndarray): The embedding of the user's query.
            top_k (int): The number of top categories to return.
        
        Returns:
            list[str]: A list of predicted category names.
        """

        # Query the CATEGORY collection in ChromaDB
        try:
            # results = await self.chroma.aquery_collection(
            #     collection_name=self.collection_name,
            #     query_embedding=query_embedding,
            #     n_results=top_k
            # )
            # # The predicted categories are the IDs/documents of the results
            # predicted_categories = results['documents'][0]
            # return predicted_categories
            results = await self.chroma.aquery_collection(
                collection_name=self.collection_name,
                query_embedding=query_embedding,
                n_results=top_k*6,
            )
            # The predicted categories are the IDs/documents of the results
            predicted_categories = results['documents'][0]
            
            # This handles your "non-unique results" question!
            # Convert to a dictionary and back to a list to get unique values while preserving order.
            unique_predicted_categories = list(dict.fromkeys(predicted_categories))[:top_k]
            
            return unique_predicted_categories
        except Exception as e:
            logger.error(f"Could not query category collection: {e}. Intent classification disabled for this query.")
            return []
</file>

<file path="SRP/app/main.py">
# app/main.py
from fastapi import FastAPI
from .api.routers import router as api_router


app = FastAPI(title="Flipkart Search Service")

app.include_router(api_router, prefix="/api")

@app.get("/")
def read_root():
    return {"message": "Welcome to the Flipkart Search API"}
</file>

<file path="SRP/scripts/add_new_product.py">
import pandas as pd
import requests
import sys
from pathlib import Path

# Add project root to path to import from app and other scripts
sys.path.append(str(Path(__file__).resolve().parent.parent))

from app.core.config import PRODUCT_DATA_PATH, API_BASE_URL
# from scripts.utils import append_product_to_csv # Optional: if you want to use the helper

API_URL = f"{API_BASE_URL}/api/products"

def find_product_by_pid(pid_to_find: str):
    """
    Finds a product in the main CSV file by its PID.
    """
    try:
        df = pd.read_csv(PRODUCT_DATA_PATH)
        product_row = df[df['pid'] == pid_to_find]
        
        if product_row.empty:
            print(f"Error: Product with PID '{pid_to_find}' not found in {PRODUCT_DATA_PATH}")
            return None
            
        # Return the first match as a dictionary
        return product_row.iloc[0].to_dict()
    except FileNotFoundError:
        print(f"Error: Product data file not found at '{PRODUCT_DATA_PATH}'")
        return None

def prepare_product_for_api(product_dict: dict):
    """
    Takes a product dictionary and prepares it for the API payload.
    This includes creating 'combined_text' and structuring the metadata.
    """
    # Replicate the cleaning and data prep logic from the bulk indexer
    product_name = str(product_dict.get('product_name', ''))
    brand = str(product_dict.get('brand', 'Unknown'))
    description = str(product_dict.get('description', ''))
    subcategory = str(product_dict.get('subcategory', '')).strip()

    combined_text = f"{product_name}. {brand}. {description}"
    
    # Structure the payload to match the Pydantic model in the API
    api_payload = {
        "id": product_dict['pid'],
        "document": combined_text,
        "metadata": {
            "subcategory": subcategory
            # You can add more metadata here if your service uses it
        }
    }
    return api_payload

def main():
    """
    Main function to drive the script.
    """
    if len(sys.argv) < 2:
        print("Usage: python scripts/add_new_product.py <PID_OF_PRODUCT_TO_ADD>")
        sys.exit(1)
        
    target_pid = sys.argv[1]
    print(f"Attempting to add product with PID: {target_pid}")

    # 1. Find the product in the master CSV
    product_data = find_product_by_pid(target_pid)
    if not product_data:
        return

    # 2. Prepare the data for the API endpoint
    api_payload = prepare_product_for_api(product_data)
    
    print("\nPrepared API Payload:")
    print(api_payload)

    # 3. Send the request to the running API server
    print(f"\nSending data to API at {API_URL}...")
    try:
        # The API expects a list of products, so we wrap our payload in a list
        response = requests.post(API_URL, json=[api_payload])
        response.raise_for_status() # Raise an exception for HTTP errors
        
        print("\n--- Success! ---")
        print(f"Status Code: {response.status_code}")
        print(f"Response: {response.json()}")
        print(f"Product '{target_pid}' should now be searchable in the index.")

    except requests.exceptions.RequestException as e:
        print("\n--- API Request Failed ---")
        print(f"Could not connect to the search API at {API_URL}.")
        print("Please ensure the uvicorn server is running.")
        print(f"Error details: {e}")

if __name__ == "__main__":
    main()
</file>

<file path="SRP/scripts/utils.py">
import pandas as pd
import os
from app.core.config import PRODUCT_DATA_PATH

def append_product_to_csv(product_data: dict):
    """
    Appends a new product row to the main product CSV file.
    Creates the file with headers if it doesn't exist.

    Args:
        product_data (dict): A dictionary representing a single product row.
                             Must contain all columns for the CSV.
    """
    file_exists = os.path.isfile(PRODUCT_DATA_PATH)
    
    # Create a DataFrame from the new product data
    new_product_df = pd.DataFrame([product_data])
    
    # If file exists, append without header. Otherwise, create with header.
    new_product_df.to_csv(
        PRODUCT_DATA_PATH, 
        mode='a', 
        header=not file_exists, 
        index=False
    )
    
    if file_exists:
        print(f"Successfully appended product with PID '{product_data.get('pid')}' to {PRODUCT_DATA_PATH}")
    else:
        print(f"Successfully created {PRODUCT_DATA_PATH} and added product with PID '{product_data.get('pid')}'")
</file>

<file path="SRP/.dockerignore">
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
env/
venv/
.env
.git
.gitignore
.dockerignore
db_storage/
</file>

<file path="SRP/commands.txt">
uvicorn app.main:app --reload
python scripts/bulk_indexer.py
python test_client_with_k.py
</file>

<file path="SRP/test_subcategory_intent.py">
import pandas as pd
import sys
from pathlib import Path
import asyncio
from tqdm.asyncio import tqdm # Ensure this is the asyncio version of tqdm

# Add the project root to the Python path
sys.path.append(str(Path(__file__).resolve().parent))

from app.services.search_service import SearchService
from app.db.chroma_manager import ChromaManager
from app.core.config import QUERY_CLASSIFICATION_TOP_K

test_data_path = "data/gemini_generated_queries_live.csv"
async def run_evaluation():
    """
    Loads the test queries, runs them through the IntentClassifier,
    and calculates performance metrics.
    """
    print("--- Intent Classifier Evaluation Script ---")
    
    # --- 1. Initialization ---
    print("Initializing necessary components (ChromaDB, Models)...")
    try:
        chroma_manager = ChromaManager()
        search_service = SearchService(chroma_manager)
        intent_classifier = search_service.intent_classifier
        print("Components initialized.")
    except Exception as e:
        print(f"\nFATAL ERROR: Could not initialize components: {e}")
        print("Please ensure you have run 'scripts/bulk_indexer.py' successfully first.")
        return

    # --- 2. Load Test Data ---
    try:
        test_df = pd.read_csv(test_data_path)
        print(f"Loaded {len(test_df)} test queries from '{test_data_path}'.")
    except FileNotFoundError:
        print(f"\nFATAL ERROR: Test data file not found at '{test_data_path}'")
        print("Please run 'scripts/generate_test_queries.py' first.")
        return

    # --- 3. Run Evaluation Loop ---
    
    # This nested function is a coroutine function.
    # Calling it creates a coroutine object.
    async def evaluate_row(row):
        original_cat = row['original_subcategory']
        query = row['generated_query']
        
        # Note: We need the embed_model from the search_service
        query_embedding = search_service.embed_model.encode(query)
        predicted_cats = await intent_classifier.predict_categories(
            query_embedding=query_embedding,
            top_k=QUERY_CLASSIFICATION_TOP_K
        )
        
        if original_cat in predicted_cats:
            rank = predicted_cats.index(original_cat) + 1
            return {"hit": True, "rank": rank, "original": original_cat, "predicted": predicted_cats, "query": query}
        else:
            return {"hit": False, "rank": 0, "original": original_cat, "predicted": predicted_cats, "query": query}

    # Create a list of coroutine objects
    tasks = [evaluate_row(row) for _, row in test_df.iterrows()]
    
    # --- THE FIX IS HERE: Unpack the list with the '*' operator ---
    results = await tqdm.gather(*tasks, desc="Evaluating Queries")

    # --- 4. Process Results and Calculate Metrics ---
    hit_count = 0
    top_1_hit_count = 0
    mrr_sum = 0.0
    misses = []
    
    for res in results:
        if res["hit"]:
            hit_count += 1
            mrr_sum += 1.0 / res["rank"]
            if res["rank"] == 1:
                top_1_hit_count += 1
        else:
            misses.append(res)
            
    total_queries = len(test_df)
    miss_count = total_queries - hit_count
    
    # Calculate final metrics
    top_k_accuracy = (hit_count / total_queries) * 100 if total_queries > 0 else 0
    top_1_accuracy = (top_1_hit_count / total_queries) * 100 if total_queries > 0 else 0
    mean_reciprocal_rank = mrr_sum / total_queries if total_queries > 0 else 0

    # --- 5. Display Report ---
    print("\n" + "="*50)
    print("  Intent Classification Evaluation Report")
    print("="*50)
    print(f"Total Queries Evaluated: {total_queries}")
    print(f"Correct Predictions (Hit Count): {hit_count}")
    print(f"Incorrect Predictions (Miss Count): {miss_count}")
    print("-" * 50)
    print(f"Top-{QUERY_CLASSIFICATION_TOP_K} Accuracy: {top_k_accuracy:.2f}%")
    print(f"Top-1 Accuracy: {top_1_accuracy:.2f}%")
    print(f"Mean Reciprocal Rank (MRR): {mean_reciprocal_rank:.4f}")
    print("="*50)

    if misses:
        print(f"\nAnalysis of Top {min(50, len(misses))} Misses:")
        for i, miss in enumerate(misses[:50]):
            print(f"  {i+1}. Query: '{miss['query']}'")
            print(f"     Expected: '{miss['original']}'")
            print(f"     Predicted: {miss['predicted']}\n")

async def main():
    await run_evaluation()

if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="package.json">
{
  "name": "flipkart",
  "version": "1.0.0",
  "description": "Sijeesh Miziha's Flipkart Clone is done with top-notch features for the entrepreneur startups like Flipkart it has RazorPay Integration and get money from anywhere. This Flipkart clone with the best features in mobile, web, and iOS platforms, Completely responsive design using Material UI. - 🧪 **Kindly Please Support Me**   - I can provide brand-free products and full technical support for 1 year along with 1-year free update support and moreover - 👁 **Well typed**   - Clean JavaScript code with good folder structure., - 📄 **Well documented**   - I can provide full reference & installation documentation alongside detailed guides through my Youtube Channel Sijeesh Miziha feel free to subscribe    - If You supporting me., then I can also create the full lecture video from the scratch..,you can learn React.js as beginer  - **Requirements to fork this repo**    - Strong knowledge of JavaScript    - React js, redux , redux-thunk , context    - Knowledge of Express js & MVC architecture    - Basic knowledge in MongoDB & Mongoose",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/sijeeshmiziha/flipkart.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/sijeeshmiziha/flipkart/issues"
  },
  "homepage": "https://github.com/sijeeshmiziha/flipkart#readme"
}
</file>

<file path="client/src/Components/Header/CustomButtons.jsx">
import { useState, useContext } from 'react';
import { makeStyles, Box, Typography, Button } from '@material-ui/core';
import { Link } from 'react-router-dom';
import { ShoppingCart } from '@material-ui/icons';
import LoginDialog from '../Login/LoginDialog';
import { LoginContext } from '../../context/ContextProvider';
import { useSelector } from 'react-redux';
import Profile from './Profile';

const useStyle = makeStyles(theme => ({
    wrapper: {
        display: 'flex',
        alignItems: 'center',
        gap: '40px',
        margin: '0 5% 0 auto', // Pushes the whole group to the right
    },
    linkText: {
        fontSize: 16,
        fontWeight: 500,
        cursor: 'pointer',
    },
    homePageText: {
        color: '#000000',
    },
    defaultText: {
        color: '#FFFFFF',
    },
    login: {
        color: '#2874f0',
        background: '#FFFFFF',
        textTransform: 'none',
        fontWeight: 600,
        borderRadius: 2,
        padding: '5px 40px',
        height: 32,
        boxShadow: '0 2px 4px 0 rgb(0 0 0 / 20%)',
    },
    cartLink: {
        display: 'flex',
        alignItems: 'center',
        gap: '8px',
        textDecoration: 'none'
    }
}));

const CustomButtons = ({ isHomePage }) => {
    const classes = useStyle();
    const [open, setOpen] = useState(false);
    const { account, logout, setAccount } = useContext(LoginContext);
    const { cartItems } = useSelector(state => state.cart);

    const openDialog = () => setOpen(true);
    const textColorClass = isHomePage ? classes.homePageText : classes.defaultText;

    return (
        <Box className={classes.wrapper}>
            {account ? (
                <Profile account={account} setAccount={setAccount} logout={logout} isHomePage={isHomePage} />
            ) : (
                <Button variant="contained" onClick={openDialog} className={classes.login}>
                    Login
                </Button>
            )}

            <Typography className={`${classes.linkText} ${textColorClass}`}>
                Become a Seller
            </Typography>
            
            <Typography className={`${classes.linkText} ${textColorClass}`}>
                More
            </Typography>

            <Link to="/cart" className={`${classes.cartLink} ${textColorClass}`}>
                <ShoppingCart />
                <Typography>Cart</Typography>
            </Link>
            
            <LoginDialog open={open} setOpen={setOpen} setAccount={setAccount} />
        </Box>
    );
};

export default CustomButtons;
</file>

<file path="client/src/Components/Header/Header.jsx">
import { AppBar, Toolbar, makeStyles, Box, Typography, withStyles, IconButton, Drawer, List } from '@material-ui/core';
import { Link, useLocation } from 'react-router-dom';
import CustomButtons from './CustomButtons';
import Search from './Search';
import { Menu } from '@material-ui/icons';
import { useState } from 'react';

const useStyle = makeStyles(theme => ({
    header: {
        background: '#2874f0',
        height: 56, // Adjusted height
        boxShadow: 'none',
    },
    headerHome: {
        background: '#FFFFFF',
        color: '#000000',
        borderBottom: '1px solid #e0e0e0',
    },
    component: {
        marginLeft: '8%',
        lineHeight: 0,
        textDecoration: 'none',
        color: 'inherit',
    },
    logoText: {
        fontSize: '20px',
        fontWeight: 'bold',
        fontStyle: 'italic',
        color: '#FFFFFF',
    },
    logoTextHome: {
        color: '#2874f0',
    },
    container: {
        display: 'flex',
    },
    subHeading: {
        fontSize: 10,
        fontStyle: 'italic',
        color: '#FFFFFF',
    },
    subHeadingHome: {
        color: '#878787',
    },
    subURL: {
        width: 10,
        height: 10,
        marginLeft: 4
    },
    // --- UI ENHANCEMENT: Toolbar is now the main layout container ---
    toolbar: {
        display: 'flex',
        alignItems: 'center',
        minHeight: 56
    },
    // --- UI ENHANCEMENT: New style for the search container ---
    searchContainer: {
        flexGrow: 1, // Allows this container to take up all available horizontal space
        display: 'flex',
        justifyContent: 'center', // Centers the Search bar within this container
        padding: '0 20px', // Adds some breathing room around the search bar
    },
    list: {
        width: 250
    },
    menuButton: {
        display: 'none',
        [theme.breakpoints.down('sm')]: {
            display: 'block'
        }
    },
}));

// Using withStyles is fine, but for consistency, we'll use the toolbar class from makeStyles.
// const ToolBar = withStyles({ root: { minHeight: 56 } })(Toolbar);

const Header = () => {
    const classes = useStyle();
    const location = useLocation();
    const isHomePage = location.pathname === '/';
    
    const subURL = 'https://static-assets-web.flixcart.com/www/linchpin/fk-cp-zion/img/plus_aef861.png';

    const [open, setOpen] = useState(false);
    const handleClose = () => { setOpen(false); }
    const handleOpen = () => { setOpen(true); }

    const list = () => (
        <Box className={classes.list} onClick={handleClose}>
            <List><listItem button><CustomButtons isHomePage={isHomePage} /></listItem></List>
        </Box>
    );

    return (
        <AppBar position="fixed" className={`${classes.header} ${isHomePage ? classes.headerHome : ''}`}>
            {/* --- UI ENHANCEMENT: Use the new styled Toolbar --- */}
            <Toolbar className={classes.toolbar}>
                <IconButton color="inherit" className={classes.menuButton} onClick={handleOpen}>
                    <Menu />
                </IconButton>

                <Drawer open={open} onClose={handleClose}>{list()}</Drawer>

                <Link to='/' className={classes.component}>
                    <Typography className={`${classes.logoText} ${isHomePage ? classes.logoTextHome : ''}`}>
                        Flipkart
                    </Typography>
                    <Box component="span" className={classes.container}>
                        <Typography className={`${classes.subHeading} ${isHomePage ? classes.subHeadingHome : ''}`}>
                            Explore <Box component="span" style={{color:'#FFE500'}}>Plus</Box>
                        </Typography>
                        <img src={subURL} className={classes.subURL} alt="" />
                    </Box>
                </Link>
                
                {/* --- UI ENHANCEMENT: Search bar is now wrapped for centering --- */}
                <Box className={classes.searchContainer}>
                    <Search />
                </Box>
                
                {/* CustomButtons is now a direct child, pushed to the right by the search container */}
                <CustomButtons isHomePage={isHomePage} />
            </Toolbar>
        </AppBar>
    )
}

export default Header;
</file>

<file path="client/src/Components/Home/NarBar.jsx">
import { Box, makeStyles, Typography } from '@material-ui/core';
import { navData } from '../../constant/data';

// --- UI ENHANCEMENT: Styles completely overhauled to match Flipkart's UI ---
const useStyle = makeStyles(theme => ({
    component: {
        display: 'flex',
        justifyContent: 'space-between',
        margin: '0 64px', // Add horizontal margin
        overflowX: 'auto', // Allow scrolling on small screens
        background: '#fff', // White background
        padding: '12px 8px',
        [theme.breakpoints.down('md')]: {
            margin: 0
        }
    },
    container: {
        padding: '12px 8px',
        textAlign: 'center',
        cursor: 'pointer',
    },
    image: {
        width: 64
    },
    text: {
        fontSize: 14,
        fontWeight: 600, // Bolder font
        fontFamily: 'inherit'
    }
}));

const NavBar = () => {
    const classes = useStyle();
    return (
        <Box className={classes.component}>
            {
                navData.map(data => (
                    <Box className={classes.container} key={data.text}>
                        <img src={data.url} className={classes.image} alt={data.text} />
                        <Typography className={classes.text}>{data.text}</Typography>
                    </Box>
                ))
            }
        </Box>
    )
}

export default NavBar;
</file>

<file path="client/src/Components/Home.jsx">
import { Box, makeStyles } from '@material-ui/core';
import { useHistory } from 'react-router-dom';
import NavBar from './Home/NarBar'; // Corrected import name
import Banner from './Home/Banner';
import MidSlide from './Home/MidSlide';
import MidSection from './Home/MidSection';
import Slide from './Home/Slide';
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux'; // hooks
import { getProducts as listProducts } from '../redux/actions/productActions';
import CategoryMenu from "./Home/CategoryMenu";

// --- UI ENHANCEMENT: Styles updated for new layout and background color ---
const useStyle = makeStyles({
    // This wrapper is the new top-level container after the header
    homeWrapper: {
        marginTop: 55, // Clears the fixed header
    },
    // This component now only controls the main content area below the nav
    component: {
        padding: 10,
        background: '#F1F3F6' // This is the light grey background color from Flipkart
    }
});

const Home = () => {
    const classes = useStyle();

    // --- All your existing logic is preserved ---
    const getProducts = useSelector(state => state.getProducts);
    const { products } = getProducts;

    const dispatch = useDispatch();
    const history = useHistory();

    const handleCategoryClick = (cat) => {
        history.push(`/search?q=${encodeURIComponent(cat)}`);
    };

    useEffect(() => {
        dispatch(listProducts())
    }, [dispatch]);

    return (
        // --- UI ENHANCEMENT: The Fragment <> is replaced with the new wrapper Box ---
        <Box className={classes.homeWrapper}> 
            <NavBar />
            {/* 
              Note: The original Flipkart doesn't have a second category menu here.
              You can choose to keep or remove this based on your desired UI.
              I'm keeping it as you had it.
            */}
            <CategoryMenu onCategoryClick={handleCategoryClick} />
            
            <Box className={classes.component}>
                <Banner />
                <MidSlide products={products} />
                <MidSection />
                <Slide
                    data={products} 
                    title='Discounts for You'
                    timer={false} 
                    multi={true} 
                />
                <Slide
                    data={products} 
                    title='Suggested Items'
                    timer={false} 
                    multi={true} 
                />
                <Slide
                    data={products} 
                    title='Top Selection'
                    timer={false} 
                    multi={true} 
                />
                <Slide
                    data={products} 
                    title='Recommended Items'
                    timer={false} 
                    multi={true} 
                />
            </Box>
        </Box>
    )
}

export default Home;
</file>

<file path="server/database/db.js">
import mongoose from 'mongoose';
import dotenv from 'dotenv';

// This ensures your .env file is read
dotenv.config();

const Connection = async () => {
    const password = process.env.DB_PASSWORD;
    const userName=process.env.DB_USERNAME;
    // This is the correct connection string you got from the Atlas website
    const URL = `mongodb+srv://${userName}:${password}@cluster0.mwn1mjt.mongodb.net/flipkart?retryWrites=true&w=majority&appName=Cluster0`;

    try {
        // Connect without the old, unnecessary options
        await mongoose.connect(URL);
        
        console.log('Database Connected Successfully');
    } catch(error) {
        console.log('Error: ', error.message);
    }
};

export default Connection;
</file>

<file path="server/model/categorySchema.js">
import mongoose from 'mongoose';

const categorySchema = new mongoose.Schema({
  category: { type: String, trim: true },
  subcategory: { type: String, trim: true },
  search_string: { type: String, trim: true }
});

export default mongoose.model('Category', categorySchema);
</file>

<file path="server/importCategories.js">
import fs from 'fs';
import path from 'path';
import csv from 'csv-parser';
import mongoose from 'mongoose';
import dotenv from 'dotenv';
import Category from './model/categorySchema.js'; // Import the model

dotenv.config();

// --- Define your two CSV files ---
const BASE_CATEGORIES_FILE = 'categories_subcategories_list.csv';
const SEARCH_STRINGS_FILE = 'combined_unique.csv';

// Helper function to process a single CSV file and return its data as a promise
const processCsvFile = (filePath, isSearchStringFile = false) => {
    return new Promise((resolve, reject) => {
        const documents = [];
        console.log(`Reading from: ${filePath}`);

        if (!fs.existsSync(filePath)) {
            console.warn(`WARNING: File not found, skipping: ${filePath}`);
            return resolve([]); // Resolve with an empty array if file doesn't exist
        }

        fs.createReadStream(filePath)
            .pipe(csv())
            .on('data', (row) => {
                const doc = {
                    category: row.category ? row.category.trim() : null,
                    subcategory: row.subcategory ? row.subcategory.trim() : null,
                };

                // Only add search_string if it's the specific file and the column exists
                if (isSearchStringFile && row.search_string && row.search_string.trim()) {
                    doc.search_string = row.search_string.trim();
                }

                // Ensure we have at least a subcategory to make the entry useful
                if (doc.subcategory) {
                    documents.push(doc);
                }
            })
            .on('end', () => {
                console.log(`Finished processing ${filePath}. Found ${documents.length} valid rows.`);
                resolve(documents);
            })
            .on('error', (error) => {
                console.error(`Error reading ${filePath}:`, error.message);
                reject(error);
            });
    });
};


async function importAllCategoryData() {
    try {
        if (!process.env.DB_PASSWORD) {
            throw new Error('DB_PASSWORD environment variable is not set!');
        }
        const password = process.env.DB_PASSWORD;
        const URL = `mongodb+srv://yashanand37:${password}@cluster0.mwn1mjt.mongodb.net/flipkart?retryWrites=true&w=majority&appName=Cluster0`;
        
        console.log('Connecting to MongoDB...');
        await mongoose.connect(URL, { useNewUrlParser: true, useUnifiedTopology: true });
        console.log('Database connected successfully for combined category import.');
    } catch (error) {
        console.error('Error connecting to database:', error.message);
        return;
    }

    try {
        await Category.deleteMany({});
        console.log('Existing categories collection cleared.');

        // --- Process both files concurrently ---
        const basePath = path.resolve(process.cwd());
        const [baseCategories, searchStringCategories] = await Promise.all([
            processCsvFile(path.join(basePath, BASE_CATEGORIES_FILE), false),
            processCsvFile(path.join(basePath, SEARCH_STRINGS_FILE), true)
        ]);

        // --- Combine the data from both files ---
        const allDocuments = [...baseCategories, ...searchStringCategories];

        if (allDocuments.length > 0) {
            await Category.insertMany(allDocuments);
            console.log(`SUCCESS: ${allDocuments.length} total documents imported from both files!`);
        } else {
            console.log('No documents found in either CSV to import.');
        }

    } catch (error) {
        console.error('An error occurred during the import process:', error.message);
    } finally {
        mongoose.connection.close();
        console.log('Database connection closed.');
    }
}

importAllCategoryData();
</file>

<file path="server/importData.js">
import fs from 'fs';
import path from 'path';
import csv from 'csv-parser';
import mongoose from 'mongoose';
import dotenv from 'dotenv';
import Product from './model/productSchema.js';

dotenv.config();

async function importCSVData() {
    try {
        const password = process.env.DB_PASSWORD;
        const URL = `mongodb+srv://yashanand37:${password}@cluster0.mwn1mjt.mongodb.net/flipkart?retryWrites=true&w=majority&appName=Cluster0`;
        await mongoose.connect(URL);
        console.log('Database connected successfully for import.');
    } catch (error) {
        console.error('Error connecting to database:', error.message);
        return;
    }

    try {
        await Product.deleteMany({});
        console.log('Existing products collection cleared.');
    } catch (error) {
        console.error('Error clearing products collection:', error.message);
        mongoose.connection.close();
        return;
    }

    const productsToSave = [];
    const csvFilePath = path.resolve(process.cwd(), 'cleaned_combined.csv');

    fs.createReadStream(csvFilePath)
        .pipe(csv())
        .on('data', (row) => {
            // Parse prices properly - remove currency symbols and convert to numbers
            const retailPrice = parseFloat(row.retail_price?.replace(/[₹,]/g, '')) || 0;
            const discountedPrice = parseFloat(row.discounted_price?.replace(/[₹,]/g, '')) || 0;
            
            let discount = '0%';
            if (retailPrice > 0 && discountedPrice < retailPrice) {
                discount = Math.round(((retailPrice - discountedPrice) / retailPrice) * 100) + '% off';
            }

            const formattedProduct = {
                id: row.pid, // Use pid as the main ID
                pid: row.pid, // Keep pid field as well
                url: row.image || 'https://via.placeholder.com/300',
                detailUrl: row.image || 'https://via.placeholder.com/300',
                title: {
                    shortTitle: row.category || row.subcategory || 'Product',
                    longTitle: row.product_name || 'Unknown Product'
                },
                price: {
                    mrp: retailPrice,
                    cost: discountedPrice,
                    discount: discount
                },
                description: row.description || 'No description available.',
                discount: discount,
                tagline: row.brand || row.category || 'Product',
                brand: row.brand,
                category: row.category,
                subcategory: row.subcategory,
                rating: parseFloat(row.product_rating) || 0,
                specifications: row.product_specifications
            };
            
            console.log(`Processing: ${formattedProduct.title.longTitle}`);
            productsToSave.push(formattedProduct);
        })
        .on('end', async () => {
            console.log('CSV file processing finished.');
            try {
                if (productsToSave.length > 0) {
                    await Product.insertMany(productsToSave);
                    console.log(`${productsToSave.length} products imported successfully!`);
                } else {
                    console.log('No products found in CSV to import.');
                }
            } catch (error) {
                console.error('Error inserting data:', error.message);
            } finally {
                mongoose.connection.close();
                console.log('Database connection closed.');
            }
        });
}

importCSVData();
</file>

<file path="SRP/app/core/config.py">
# app/core/config.py
from pathlib import Path
import os

# --- Configuration for SRP Application ---
# Base directory for the application
ROOT_DIR = Path(__file__).parent.parent.parent


# Final number of results to display in the client script
CLIENT_DISPLAY_COUNT=10

# --- Data Files ---
# All files are expected to be in the 'data/' directory
PRODUCT_DATA_FILE="product_data.csv"
# CATEGORY_DATA_FILE=subcategories_with_search_strings.csv
CATEGORY_DATA_FILE="search_strings_subcategories.csv"

# --- Data File Paths ---
PRODUCT_DATA_PATH = ROOT_DIR / "data" / PRODUCT_DATA_FILE
CATEGORY_DATA_PATH = ROOT_DIR / "data" / CATEGORY_DATA_FILE

# --- ChromaDB Collection Names ---

# ChromaDB settings
DB_PATH = str(ROOT_DIR / "db_storage")
PRODUCT_COLLECTION_NAME="products_v1"
CATEGORY_COLLECTION_NAME="categories_v1"

# Model settings
EMBEDDING_MODEL = 'all-MiniLM-L6-v2' # Use a smaller one for faster local iteration
RERANKER_MODEL = 'cross-encoder/ms-marco-MiniLM-L-6-v2'

# --- Search Hyperparameters ---
# Number of top categories to predict for a query (K)
QUERY_CLASSIFICATION_TOP_K=3

# Number of candidates to retrieve for each predicted category (M)
CANDIDATES_PER_CATEGORY=70

# Total candidates to retrieve if intent classification fails
FALLBACK_CANDIDATE_COUNT=200

# Batch size for bulk indexing
BATCH_SIZE = 512

# --- API Configuration ---
API_BASE_URL= "http://127.0.0.1:8000"
</file>

<file path="SRP/app/services/search_service.py">
# app/services/search_service.py

from ..db.chroma_manager import ChromaManager
from ..models.model_loader import get_embedding_model, get_reranker_model
from .intent_classifier import IntentClassifier # Import the new class
import logging
import asyncio # Import asyncio
from ..core.config import PRODUCT_COLLECTION_NAME, QUERY_CLASSIFICATION_TOP_K, CANDIDATES_PER_CATEGORY, FALLBACK_CANDIDATE_COUNT


logger = logging.getLogger(__name__)

class SearchService:
    def __init__(self, chroma_manager: ChromaManager):
        self.chroma = chroma_manager
        self.embed_model = get_embedding_model()
        self.reranker = get_reranker_model()
        # The classifier now needs the chroma_manager
        self.intent_classifier = IntentClassifier(chroma_manager)
        self.product_collection_name = PRODUCT_COLLECTION_NAME
    
    async def search(self, query: str):
        # Stage 1: Query Embedding
        query_embedding = self.embed_model.encode(query)

        # Stage 2: Intent Classification (This is fast, can remain sync)
        predicted_cats = await self.intent_classifier.predict_categories(query_embedding, top_k=QUERY_CLASSIFICATION_TOP_K)
        logger.info(f"Predicted intent categories: {predicted_cats}")

        # Stage 2: Concurrent Candidate Retrieval
        tasks = []
        if not predicted_cats:
            # Fallback for general search
            task = self.chroma.aquery_collection(
                collection_name=self.product_collection_name,
                query_embedding=query_embedding,
                n_results=FALLBACK_CANDIDATE_COUNT
            )
            tasks.append(task)
        else:
            logger.info(f"Fetching {CANDIDATES_PER_CATEGORY} candidates for each of {len(predicted_cats)} categories.")
            # Create a list of concurrent tasks, one for each category query
            for category in predicted_cats:
                where_filter = {"subcategory": {"$eq": category}}
                task = self.chroma.aquery_collection(
                    collection_name=self.product_collection_name,
                    query_embedding=query_embedding,
                    where_filter=where_filter,
                    n_results=CANDIDATES_PER_CATEGORY
                )
                tasks.append(task)
        
        # Run all tasks concurrently and wait for them all to complete
        logger.info(f"Concurrently fetching candidates for {len(tasks)} tasks...")
        all_results = await asyncio.gather(*tasks)
        logger.info("All candidate fetches complete.")

        # Process the results from all concurrent calls
        all_candidates = {}
        for result_set in all_results:
            if result_set and result_set.get('ids') and result_set['ids'][0]:
                for i, pid in enumerate(result_set['ids'][0]):
                    all_candidates[pid] = result_set['documents'][0][i]

        candidate_ids = list(all_candidates.keys())
        candidate_docs = list(all_candidates.values())
        logger.info(f"Total unique candidates to rerank: {len(candidate_ids)}")

        # Stage 3: Reranking (This part is CPU/GPU bound, can remain sync)
        reranker_input = {'ids': [candidate_ids], 'documents': [candidate_docs]}
        # We can run the sync reranker in a thread to avoid blocking the event loop
        loop = asyncio.get_running_loop()
        sorted_ids = await loop.run_in_executor(
            None, self._rerank_results, query, reranker_input
        )
        return sorted_ids
    
    def _rerank_results(self, query, chroma_results):
        ids = chroma_results['ids'][0]
        docs = chroma_results['documents'][0]
        
        if not ids:
            return []
            
        pairs = [[query, doc] for doc in docs]
        scores = self.reranker.predict(pairs)
        
        id_score_pairs = sorted(zip(scores, ids), key=lambda x: x[0], reverse=True)
        return [pair[1] for pair in id_score_pairs]

    def insert_products(self, products: list[dict]):
        # products is a list of dicts, each with 'id', 'document', 'metadata'
        ids = [p['id'] for p in products]
        docs = [p['document'] for p in products]
        metadatas = [p['metadata'] for p in products]

        # Generate embeddings in a batch
        embeddings = self.embed_model.encode(docs, show_progress_bar=True)
        
        # Add to DB
        self.chroma.add_items_to_collection(
            collection_name=self.product_collection_name,
            ids=ids,
            documents=docs, # Storing the combined_text as the document
            embeddings=embeddings.tolist(),
            metadatas=metadatas
        )
        logger.info("Products added successfully.")
</file>

<file path="SRP/scripts/Example.py">
import pandas as pd
import sys
from pathlib import Path
import subprocess # To call our other script

# Add project root to path to import utils
sys.path.append(str(Path(__file__).resolve().parent.parent))

from scripts.utils import append_product_to_csv
from app.core.config import PRODUCT_DATA_PATH

def main():
    """
    Demonstrates the full workflow of adding a new product.
    1. Defines a new product.
    2. Appends it to the master CSV.
    3. Calls the script to index it via the API.
    """
    print("--- Starting New Product Addition Workflow ---")

    # --- 1. Define the New Product Data ---
    # Let's add a new, high-end laptop. The PID should be unique.
    new_laptop = {
        'product_url': 'https://www.flipkart.com/lenovo-legion-7i-intel-core-i7-10th-gen-10875h-16-gb-1-tb-ssd-windows-10-home-8-gb-graphics-nvidia-geforce-rtx-2080-super-max-q-81yu0029in-gaming-laptop/p/itm48b72e2122ecd',
        'product_name': 'Lenovo Legion 7i Intel Core i7 10th Gen 10875H - (16 GB/1 TB SSD/Windows 10 Home/8 GB Graphics/NVIDIA GeForce RTX 2080 Super Max-Q) 81YU0029IN Gaming Laptop  (15.6 inch, Slate Grey, 2.25 kg, With MS Office)',
        'product_category_tree': 'Home > Computers > Laptops > Lenovo Laptops',
        'pid': 'COMFTPG2HYSS9TW3', # Our unique Product ID
        'retail_price': '₹2,79,890',
        'discounted_price': '₹2,79,890',
        'image': 'https://rukminim2.flixcart.com/image/416/416/kdyus280/computer/t/w/3/lenovo-na-gaming-laptop-original-imafuqwpncg3bzhx.jpeg?q=70&crop=false',
        'description': 'If gaming is your favorite activity, then you need the Lenovo Legion 7i 15IMHg05 Gaming Laptop for on-the-move gaming. This gaming laptop features a 39.62 cm (15.6) FHD IPS Display with the Dolby Vision HDR and 100% AdobeRGB color gamut for rich and detailed visuals. Also, for a lag-free gaming experience, it is powered by a 10th Gen Intel Core processor and 16 GB of RAM. To top it off, you will get a one-month subscription to the Xbox Game Pass on the purchase of this laptop, so you can access over 100 high-quality PC games on Windows 10 devices.',
        'product_rating': '3.5',
        'brand': 'Lenovo',
        'product_specifications': "[{'key': 'Sales Package', 'value': 'Laptop, Power Adaptor, User Guide, Warranty Documents'}, {'key': 'Model Number', 'value': '81YU0029IN'}, {'key': 'Part Number', 'value': '81YU002AIN'}, {'key': 'Series', 'value': 'Legion 7i'}, {'key': 'Color', 'value': 'Slate Grey'}, {'key': 'Type', 'value': 'Gaming Laptop'}, {'key': 'Suitable For', 'value': 'Gaming'}, {'key': 'Battery Backup', 'value': 'Upto 6 hours'}, {'key': 'Power Supply', 'value': '230 W AC Adapter'}, {'key': 'MS Office Provided', 'value': 'Yes'}, {'key': 'Dedicated Graphic Memory Type', 'value': 'GDDR6'}, {'key': 'Dedicated Graphic Memory Capacity', 'value': '8 GB'}, {'key': 'Processor Brand', 'value': 'Intel'}, {'key': 'Processor Name', 'value': 'Core i7'}, {'key': 'Processor Generation', 'value': '10th Gen'}, {'key': 'SSD', 'value': 'Yes'}, {'key': 'SSD Capacity', 'value': '1 TB'}, {'key': 'RAM', 'value': '16 GB'}, {'key': 'RAM Type', 'value': 'DDR4'}, {'key': 'Processor Variant', 'value': '10875H'}, {'key': 'Chipset', 'value': 'Intel HM470'}, {'key': 'Clock Speed', 'value': '2.3 GHz with Turbo Boost Upto 5.1 GHz'}, {'key': 'Memory Slots', 'value': '2 Slots'}, {'key': 'Expandable Memory', 'value': 'Upto 32 GB'}, {'key': 'RAM Frequency', 'value': '3200 MHz'}, {'key': 'Cache', 'value': '16 MB'}, {'key': 'Graphic Processor', 'value': 'NVIDIA GeForce RTX 2080 Super Max-Q'}, {'key': 'Number of Cores', 'value': '8'}, {'key': 'Storage Type', 'value': 'SSD'}, {'key': 'OS Architecture', 'value': '64 bit'}, {'key': 'Operating System', 'value': 'Windows 10 Home'}, {'key': 'System Architecture', 'value': '64 bit'}, {'key': 'Mic In', 'value': 'Yes'}, {'key': 'RJ45', 'value': 'Yes'}, {'key': 'USB Port', 'value': '1 x USB 3.1 ((1st Gen) (Always On)), 2 x USB 3.1 (2nd Gen), 1 x USB 3.1 Type C ((1st Gen) (with the Function of Display 1.4)), 1 x USB 3.1 Type C (2nd Gen) / Thunderbolt 3 (with the Function of DP 1.4)'}, {'key': 'HDMI Port', 'value': '1 x HDMI Port (v2.0)'}, {'key': 'Touchscreen', 'value': 'No'}, {'key': 'Screen Size', 'value': '39.62 cm (15.6 inch)'}, {'key': 'Screen Resolution', 'value': '1920 x 1080 Pixel'}, {'key': 'Screen Type', 'value': 'Full HD LED Backlit Anti-glare WVA Display (16:9 Aspect Ratio, 500 nits Brightness, 144 Hz Refresh Rate, 100% Adobe RGB Gamut, HDR400, Dolby Vision, G-Sync Support)'}, {'key': 'Speakers', 'value': 'Built-in Dual Speakers'}, {'key': 'Internal Mic', 'value': 'Dual Array Microphone'}, {'key': 'Sound Properties', 'value': '2 x 2 W Stereo Speakers with Dolby Atoms'}, {'key': 'Wireless LAN', 'value': 'IEEE 802.11ax (Wi-Fi 6)'}, {'key': 'Bluetooth', 'value': 'v5.0'}, {'key': 'Ethernet', 'value': '100/1000 Mbps'}, {'key': 'Dimensions', 'value': '359.34 x 259.04 x 19.9 mm'}, {'key': 'Weight', 'value': '2.25 kg'}, {'key': 'Disk Drive', 'value': 'Not Available'}, {'key': 'Web Camera', 'value': '720P HD Webcam'}, {'key': 'Finger Print Sensor', 'value': 'No'}, {'key': 'Security Chip', 'value': 'TPM 2.0'}, {'key': 'Keyboard', 'value': 'English RGB LED Backlit Keyboard'}, {'key': 'Backlit Keyboard', 'value': 'Yes'}, {'key': 'Pointer Device', 'value': 'Multi-touch Touchpad'}, {'key': 'Included Software', 'value': 'Microsoft Office Home and Student 2019'}, {'key': 'Additional Features', 'value': '80 WHr Li-ion Battery'}, {'key': 'Warranty Summary', 'value': '3 Years Warranty + 1 Year Legion Ultimate Support + 1 Year ADP'}, {'key': 'Warranty Service Type', 'value': 'Onsite'}, {'key': 'Covered in Warranty', 'value': '(1) Manufacturer’s warranty against faulty workmanship or defective parts; (2) ADP-Single repair once in year against all Liquid spills, unintentional bump and drops, electric surge, cracks on screen; (3) Gamer centric support 24x7 on call support, Software support in case of HDD failure'}, {'key': 'Not Covered in Warranty', 'value': '(1) Any kind of physical damage including electrical surge; (2) No software coverage in warranty; (3) Premium Care & ADP- Not covered in case of Theft, fire, rain, flood and part alteration'}, {'key': 'Domestic Warranty', 'value': '3 Year'}]",
        'category': 'Computers',
        'subcategory': 'Laptops'
    }
    print(f"\nStep 1: Defined new product with PID: '{new_laptop['pid']}'")

    # --- 2. Append the New Product to the Master CSV ---
    print(f"\nStep 2: Appending new product to '{PRODUCT_DATA_PATH.name}'...")
    try:
        append_product_to_csv(new_laptop)
    except Exception as e:
        print(f"  ERROR: Failed to append to CSV. Reason: {e}")
        return

    # --- 3. Call the `add_new_product.py` Script to Index via API ---
    print("\nStep 3: Calling the API script to push the new product to the search index...")
    
    # We use subprocess to call our other script, passing the new PID as an argument.
    # This simulates running it from the command line.
    script_path = "scripts/add_new_product.py"
    pid_to_add = new_laptop['pid']
    
    try:
        # We run 'python' and then the script path and the argument.
        # `check=True` will raise an error if the script fails.
        # `capture_output=True` and `text=True` let us see the script's output.
        result = subprocess.run(
            [sys.executable, script_path, pid_to_add],
            check=True,
            capture_output=True,
            text=True
        )
        print("  --- Output from add_new_product.py ---")
        print(result.stdout)
        if result.stderr:
            print("  --- Errors from add_new_product.py ---")
            print(result.stderr)
        
        print("\n--- Workflow Complete! ---")
        print(f"Product '{pid_to_add}' has been added to the CSV and sent to the search index.")
        print("You can now test searching for 'Aura Gaming Laptop' using the client script.")

    except FileNotFoundError:
        print(f"  ERROR: Could not find the script at '{script_path}'. Make sure you are in the project root.")
    except subprocess.CalledProcessError as e:
        print(f"  ERROR: The '{script_path}' script failed to execute.")
        print("  --- Script Output (stdout) ---")
        print(e.stdout)
        print("  --- Script Errors (stderr) ---")
        print(e.stderr)

if __name__ == "__main__":
    main()
</file>

<file path="SRP/Dockerfile">
# Start with a slim, official Python 3.12 base image
FROM python:3.12-slim

# Set the working directory inside the container
WORKDIR /app

# Set environment variables for Python
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

# Install system dependencies that might be needed for some Python packages
RUN apt-get update && apt-get install -y --no-install-recommends gcc

# Copy the requirements file first to leverage Docker layer caching
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir --upgrade pip
RUN pip install --no-cache-dir -r requirements.txt

# Copy the rest of your application code into the container
COPY . .

# Expose the port the app runs on
EXPOSE 8000

# The command to run your application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
</file>

<file path="SRP/test_client_with_k.py">
import requests
import pandas as pd
import sys
import time
import textwrap
import os
from dotenv import load_dotenv

# --- Configuration ---
API_URL = "http://localhost:8001/api/search"
load_dotenv()
PRODUCT_DATA_FILE = os.getenv("PRODUCT_DATA_FILE")
DATA_FILE_PATH = f"data/{PRODUCT_DATA_FILE}"
DEFAULT_K = int(os.getenv("CLIENT_DISPLAY_COUNT", 5))

def load_and_index_data(file_path):
    """
    Loads the product data from a CSV and sets 'pid' as the index for fast lookups.
    Returns the indexed DataFrame or None if the file is not found.
    """
    try:
        print(f"Loading and indexing data from '{file_path}'...")
        df = pd.read_csv(file_path)
        # Use 'pid' as the unique identifier and set it as the index. Clean the data.
        df.dropna(subset=['pid', 'product_name', 'description'], inplace=True)
        df.drop_duplicates(subset=['pid'], keep='first', inplace=True)

        df_indexed = df.set_index('pid')
        print("Data loaded and indexed successfully.")
        return df_indexed
    except FileNotFoundError:
        print(f"ERROR: Data file not found at '{file_path}'.")
        return None
    except KeyError:
        print(f"ERROR: The CSV file at '{file_path}' must contain a 'pid' column.")
        return None

def call_search_api(query):
    """
    Sends a search query to the API and returns the list of ranked PIDs.
    """
    print(f"\nSending query to API: '{query}'")
    try:
        start_time = time.time()
        response = requests.post(API_URL, json={"query": query})
        response.raise_for_status()  # Raise an exception for bad status codes (4xx or 5xx)
        end_time = time.time()
        
        print(f"API response received in {end_time - start_time:.2f} seconds.")
        return response.json().get('ranked_ids', [])
    except requests.exceptions.RequestException as e:
        print("\n--- API REQUEST FAILED ---")
        print(f"Could not connect to the search API at {API_URL}.")
        print("Please ensure the uvicorn server is running: `uvicorn app.main:app --reload`")
        print(f"Error details: {e}")
        return None

def display_results(indexed_df, pids, k):
    """
    Fetches product details from the indexed DataFrame and displays the top K results.
    """
    if not pids:
        print("\n--- No results found for your query. ---")
        return

    top_pids = pids[:k]
    
    # Use .loc for super-fast lookups from the indexed DataFrame
    # We use reindex to handle cases where a PID might not be in the df, filling with NaN
    results_df = indexed_df.reindex(top_pids)
    
    print("\n" + "="*50)
    print(f"  Top {min(k, len(results_df))} Search Results")
    print("="*50 + "\n")

    for i, (pid, row) in enumerate(results_df.iterrows()):
        if pd.isna(row['product_name']):
            print(f"{i+1}. Product with PID '{pid}' not found in local data file.")
            continue

        # Use textwrap for clean description formatting
        description = textwrap.shorten(str(row.get('description', 'No description available.')), width=100, placeholder="...")

        print(f"{i+1}. {row['product_name']}")
        print(f"   - PID:    {pid}")
        print(f"   - Brand:  {row.get('brand', 'N/A')}")
        print(f"   - Price:  ₹{row.get('discounted_price', 'N/A')}")
        print(f"   - Rating: {row.get('product_rating', 'N/A')}")
        print(f"   - Desc:   {description}\n")

def main():
    """
    Main function to drive the client application.
    """
    product_df_indexed = load_and_index_data(DATA_FILE_PATH)
    if product_df_indexed is None:
        sys.exit(1)

    while True:
        # --- Get user input ---
        query = input("Enter your search query (or 'quit' to exit): ")
        if query.lower() == 'quit':
            break
        if not query:
            print("Please enter a valid query.")
            continue

        try:
            k_str = input(f"How many top results to display? (e.g., {DEFAULT_K}): ")
            if not k_str:  # If user just presses Enter
                k = DEFAULT_K
            else:
                k = int(k_str)
            if k <= 0: raise ValueError
        except (ValueError, TypeError):
            print(f"Invalid number. Defaulting to {DEFAULT_K} results.")
            k = DEFAULT_K

        # --- Call API and display results ---
        ranked_pids = call_search_api(query)
        if ranked_pids is not None:
            display_results(product_df_indexed, ranked_pids, k)

if __name__ == "__main__":
    main()
</file>

<file path=".gitignore">
# Byte-compiled / optimized / C extensions
__pycache__/
*.pyc
*.pyo
*.pyd
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Virtual Environments
venv/
env/
.venv/
*/venv/
*/env/
*/.venv/

# IDE / Editor specific files
.idea/
.vscode/
*.swp
*.swo

# Environment variables
.env
.env.*

# Operating System Files
.DS_Store
Thumbs.db

# Test artifacts
.pytest_cache/
.coverage

#Non neccessary folders
SRP/db_storage/
</file>

<file path="client/src/Components/Header/Profile.jsx">
import { useState } from 'react';
import { Box, Typography, Menu, MenuItem, makeStyles } from '@material-ui/core';
import { PowerSettingsNew, AccountCircle, ExpandMore } from '@material-ui/icons';

const useStyle = makeStyles(theme => ({
    container: {
        display: 'flex',
        alignItems: 'center',
        cursor: 'pointer',
    },
    menuComponent: {
        marginTop: 40,
    },
    username: {
        marginLeft: 8,
        marginRight: 4,
        fontWeight: 600,
        fontSize: 14,
    },
    icon: {
        color: '#fff',
        [theme.breakpoints.down('sm')]: {
          color: '#2874f0',
        }
    },
    logout: {
        fontSize: 14,
        marginLeft: 20
    }
}));

// --- ENHANCEMENT: Accept `logout` as a prop ---
const Profile = ({ account, setAccount, logout, isHomePage }) => {
    const [open, setOpen] = useState(false);
    const classes = useStyle();
    const profileColor = isHomePage ? '#000000' : '#FFFFFF';

    const handleClick = (event) => {
        setOpen(event.currentTarget);
    };

    const handleClose = () => {
        setOpen(false);
    };

    // --- ENHANCEMENT: This handler now calls the passed-in logout function ---
    const handleLogout = () => {
        handleClose(); // First, close the menu
        logout();      // Then, call the logout function from the context
    };
    
    return (
        <>
            <Box onClick={handleClick} className={classes.container} style={{ color: profileColor }}>
                <AccountCircle />
                <Typography className={classes.username}>{account}</Typography>
                <ExpandMore fontSize="small" />
            </Box>

            <Menu
                anchorEl={open}
                open={Boolean(open)}
                onClose={handleClose}
                className={classes.menuComponent}
            >
                {/* --- ENHANCEMENT: onClick now calls the clean handler function --- */}
                <MenuItem onClick={handleLogout}>
                    <PowerSettingsNew fontSize='small' color='primary'/> 
                    <Typography className={classes.logout}>Logout</Typography>
                </MenuItem>
            </Menu>
        </>
    )    
}

export default Profile;
</file>

<file path="client/src/Components/SearchResults/SearchResultsPage.jsx">
import React, { useState, useEffect } from 'react';
import { 
    Box, 
    Grid, 
    Typography, 
    makeStyles, 
    Card, 
    Chip,
    CircularProgress,
    FormControl,
    FormLabel,
    FormControlLabel,
    Checkbox,
    Slider,
    TextField,
    MenuItem,
    Select,
    Button,
    Accordion,
    AccordionSummary,
    AccordionDetails
} from '@material-ui/core';
import { useLocation, Link } from 'react-router-dom';
import { Star, ExpandMore } from '@material-ui/icons';
import axios from 'axios';

const useStyles = makeStyles(theme => ({
    container: {
        padding: '20px',
        background: '#f1f3f6',
        minHeight: '100vh',
        marginTop: 55
    },
    mainContent: {
        display: 'flex',
        gap: '20px'
    },
    filterSidebar: {
        width: '300px',
        background: '#fff',
        padding: '16px',
        borderRadius: '2px',
        alignSelf: 'flex-start',
        position: 'sticky',
        top: '75px',
        maxHeight: 'calc(100vh - 100px)',
        overflowY: 'auto'
    },
    resultsContainer: {
        flex: 1
    },
    searchHeader: {
        background: '#fff',
        padding: '16px 24px',
        marginBottom: '12px',
        borderRadius: '2px',
        boxShadow: '0 1px 3px 0 rgba(0,0,0,.1)'
    },
    resultsCount: {
        fontSize: '14px',
        color: '#878787'
    },
    searchTerm: {
        fontSize: '16px',
        fontWeight: 500,
        color: '#212121'
    },
    productCard: {
        background: '#fff',
        marginBottom: '12px',
        padding: '16px',
        cursor: 'pointer',
        transition: 'all 0.3s ease',
        border: '1px solid #f0f0f0',
        '&:hover': {
            boxShadow: '0 2px 8px 0 rgba(0,0,0,.12)',
            transform: 'translateY(-1px)'
        }
    },
    productImage: {
        width: '200px',
        height: '200px',
        objectFit: 'contain',
        [theme.breakpoints.down('sm')]: {
            width: '150px',
            height: '150px'
        }
    },
    productDetails: {
        padding: '0 16px',
        flex: 1
    },
    productTitle: {
        fontSize: '16px',
        fontWeight: 400,
        color: '#212121',
        lineHeight: '1.4',
        marginBottom: '8px',
        display: '-webkit-box',
        '-webkit-line-clamp': 2,
        '-webkit-box-orient': 'vertical',
        overflow: 'hidden'
    },
    ratingContainer: {
        display: 'flex',
        alignItems: 'center',
        marginBottom: '8px'
    },
    rating: {
        background: '#388e3c',
        color: '#fff',
        padding: '2px 6px',
        borderRadius: '3px',
        fontSize: '12px',
        fontWeight: 500,
        display: 'flex',
        alignItems: 'center',
        marginRight: '8px'
    },
    priceContainer: {
        display: 'flex',
        alignItems: 'center',
        marginBottom: '8px'
    },
    currentPrice: {
        fontSize: '16px',
        fontWeight: 500,
        color: '#212121',
        marginRight: '8px'
    },
    originalPrice: {
        fontSize: '14px',
        color: '#878787',
        textDecoration: 'line-through',
        marginRight: '8px'
    },
    discount: {
        fontSize: '14px',
        color: '#388e3c',
        fontWeight: 500
    },
    features: {
        fontSize: '14px',
        color: '#878787',
        lineHeight: '1.4'
    },
    loadingContainer: {
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        height: '300px'
    },
    noResults: {
        textAlign: 'center',
        padding: '60px 20px',
        background: '#fff',
        borderRadius: '2px'
    },
    filterTitle: {
        fontSize: '14px',
        fontWeight: 600,
        marginBottom: '12px',
        color: '#212121'
    },
    priceSlider: {
        margin: '10px 0',
        color: '#2874f0'
    },
    priceInputs: {
        display: 'flex',
        gap: '10px',
        alignItems: 'center',
        marginTop: '10px'
    },
    priceInput: {
        width: '80px'
    },
    clearFilters: {
        marginTop: '20px',
        color: '#2874f0',
        borderColor: '#2874f0'
    },
    sortSelect: {
        minWidth: '200px',
        marginBottom: '16px'
    },
    sortContainer: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: '16px'
    }
}));

const SearchResultsPage = () => {
    const classes = useStyles();
    const location = useLocation();
    const [products, setProducts] = useState([]);
    const [filteredProducts, setFilteredProducts] = useState([]);
    const [loading, setLoading] = useState(true);
    const [searchTerm, setSearchTerm] = useState('');

    // Filter states
    const [priceRange, setPriceRange] = useState([0, 100000]);
    const [selectedBrands, setSelectedBrands] = useState([]);
    const [selectedCategories, setSelectedCategories] = useState([]);
    const [minRating, setMinRating] = useState(0);
    const [sortBy, setSortBy] = useState('relevance');

    // Available filter options
    const [availableBrands, setAvailableBrands] = useState([]);
    const [availableCategories, setAvailableCategories] = useState([]);

    // Extract search query from URL parameters
    useEffect(() => {
    const urlParams = new URLSearchParams(location.search);
    const query = urlParams.get('q') || ''; // The query for the API
    const originalQuery = urlParams.get('oq'); // The query for display

    // Use the original query for display if it exists, otherwise fall back to the main query
    setSearchTerm(originalQuery || query);

    // The API call still uses the high-quality 'q' parameter
    if (query) {
        fetchSearchResults(query);
    }
}, [location.search]);

   const fetchSearchResults = async (query) => {
    setLoading(true);
    try {
        // This user ID is hardcoded in your original file, keeping it for consistency.
        const userId = '123'; 
        const { data } = await axios.get(`http://localhost:8000/search?q=${query}&userId=${userId}`);
        
        // The 'data' variable now contains the final array of full product objects.
        // We can use it directly.
        const validProducts = data.filter(product => product !== null);

        setProducts(validProducts);
        setFilteredProducts(validProducts);

        // Extract unique brands and categories from the results
        const brands = [...new Set(validProducts.map(p => p.brand).filter(Boolean))];
        const categories = [...new Set(validProducts.map(p => p.category).filter(Boolean))];
        setAvailableBrands(brands);
        setAvailableCategories(categories);

        // Set price range based on products
        const prices = validProducts.map(p => p.price?.cost || 0).filter(p => p > 0);
        if (prices.length > 0) {
            const minPrice = Math.floor(Math.min(...prices));
            const maxPrice = Math.ceil(Math.max(...prices));
            // Ensure min is not greater than max
            setPriceRange([minPrice > maxPrice ? maxPrice : minPrice, maxPrice]);
        }

    } catch (error) {
        console.error('Error fetching search results:', error);
        setProducts([]);
        setFilteredProducts([]);
    } finally {
        setLoading(false);
    }
};

    // Apply filters whenever filter states change
    useEffect(() => {
        applyFilters();
    }, [products, priceRange, selectedBrands, selectedCategories, minRating, sortBy]);

    const applyFilters = () => {
        let filtered = [...products];

        // Price filter
        filtered = filtered.filter(product => {
            const price = product.price?.cost || 0;
            return price >= priceRange[0] && price <= priceRange[1];
        });

        // Brand filter
        if (selectedBrands.length > 0) {
            filtered = filtered.filter(product => 
                selectedBrands.includes(product.brand)
            );
        }

        // Category filter
        if (selectedCategories.length > 0) {
            filtered = filtered.filter(product => 
                selectedCategories.includes(product.category)
            );
        }

        // Rating filter
        if (minRating > 0) {
            filtered = filtered.filter(product => 
                (product.rating || 0) >= minRating
            );
        }

        // Sort products
        switch (sortBy) {
            case 'price-low-high':
                filtered.sort((a, b) => (a.price?.cost || 0) - (b.price?.cost || 0));
                break;
            case 'price-high-low':
                filtered.sort((a, b) => (b.price?.cost || 0) - (a.price?.cost || 0));
                break;
            case 'rating':
                filtered.sort((a, b) => (b.rating || 0) - (a.rating || 0));
                break;
            case 'discount':
                filtered.sort((a, b) => {
                    const discountA = parseFloat((a.price?.discount || '0%').replace('%', ''));
                    const discountB = parseFloat((b.price?.discount || '0%').replace('%', ''));
                    return discountB - discountA;
                });
                break;
            default:
                // Keep relevance order
                break;
        }

        setFilteredProducts(filtered);
    };

    const handleBrandChange = (brand) => {
        setSelectedBrands(prev => 
            prev.includes(brand) 
                ? prev.filter(b => b !== brand)
                : [...prev, brand]
        );
    };

    const handleCategoryChange = (category) => {
        setSelectedCategories(prev => 
            prev.includes(category) 
                ? prev.filter(c => c !== category)
                : [...prev, category]
        );
    };

    const clearAllFilters = () => {
        setPriceRange([0, 100000]);
        setSelectedBrands([]);
        setSelectedCategories([]);
        setMinRating(0);
        setSortBy('relevance');
    };

    const handleProductClick = async (productId) => {
        try {
            await axios.post('http://localhost:8000/click', {
                userId: '123',
                productId: productId
            });
        } catch (error) {
            console.error('Error tracking click:', error);
        }
    };

    if (loading) {
        return (
            <Box className={classes.container}>
                <Box className={classes.loadingContainer}>
                    <CircularProgress />
                </Box>
            </Box>
        );
    }

    return (
        <Box className={classes.container}>
            <Box className={classes.mainContent}>
                {/* Filter Sidebar */}
                <Box className={classes.filterSidebar}>
                    <Typography className={classes.filterTitle}>
                        FILTERS
                    </Typography>

                    <Button 
                        variant="outlined" 
                        size="small" 
                        className={classes.clearFilters}
                        onClick={clearAllFilters}
                    >
                        Clear All Filters
                    </Button>

                    {/* Price Filter */}
                    <Accordion defaultExpanded>
                        <AccordionSummary expandIcon={<ExpandMore />}>
                            <Typography className={classes.filterTitle}>PRICE</Typography>
                        </AccordionSummary>
                        <AccordionDetails style={{ flexDirection: 'column' }}>
                            <Slider
                                value={priceRange}
                                onChange={(_, newValue) => setPriceRange(newValue)}
                                valueLabelDisplay="auto"
                                min={0}
                                max={100000}
                                className={classes.priceSlider}
                                valueLabelFormat={(value) => `₹${value.toLocaleString()}`}
                            />
                            <Box className={classes.priceInputs}>
                                <TextField
                                    size="small"
                                    label="Min"
                                    type="number"
                                    value={priceRange[0]}
                                    onChange={(e) => setPriceRange([parseInt(e.target.value) || 0, priceRange[1]])}
                                    className={classes.priceInput}
                                />
                                <Typography>to</Typography>
                                <TextField
                                    size="small"
                                    label="Max"
                                    type="number"
                                    value={priceRange[1]}
                                    onChange={(e) => setPriceRange([priceRange[0], parseInt(e.target.value) || 100000])}
                                    className={classes.priceInput}
                                />
                            </Box>
                        </AccordionDetails>
                    </Accordion>

                    {/* Brand Filter */}
                    {availableBrands.length > 0 && (
                        <Accordion defaultExpanded>
                            <AccordionSummary expandIcon={<ExpandMore />}>
                                <Typography className={classes.filterTitle}>BRAND</Typography>
                            </AccordionSummary>
                            <AccordionDetails style={{ flexDirection: 'column' }}>
                                <FormControl component="fieldset">
                                    {availableBrands.map(brand => (
                                        <FormControlLabel
                                            key={brand}
                                            control={
                                                <Checkbox
                                                    checked={selectedBrands.includes(brand)}
                                                    onChange={() => handleBrandChange(brand)}
                                                    size="small"
                                                />
                                            }
                                            label={brand}
                                        />
                                    ))}
                                </FormControl>
                            </AccordionDetails>
                        </Accordion>
                    )}

                    {/* Category Filter */}
                    {availableCategories.length > 0 && (
                        <Accordion defaultExpanded>
                            <AccordionSummary expandIcon={<ExpandMore />}>
                                <Typography className={classes.filterTitle}>CATEGORY</Typography>
                            </AccordionSummary>
                            <AccordionDetails style={{ flexDirection: 'column' }}>
                                <FormControl component="fieldset">
                                    {availableCategories.map(category => (
                                        <FormControlLabel
                                            key={category}
                                            control={
                                                <Checkbox
                                                    checked={selectedCategories.includes(category)}
                                                    onChange={() => handleCategoryChange(category)}
                                                    size="small"
                                                />
                                            }
                                            label={category}
                                        />
                                    ))}
                                </FormControl>
                            </AccordionDetails>
                        </Accordion>
                    )}

                    {/* Rating Filter */}
                    <Accordion defaultExpanded>
                        <AccordionSummary expandIcon={<ExpandMore />}>
                            <Typography className={classes.filterTitle}>CUSTOMER RATING</Typography>
                        </AccordionSummary>
                        <AccordionDetails style={{ flexDirection: 'column' }}>
                            <FormControl component="fieldset">
                                {[4, 3, 2, 1].map(rating => (
                                    <FormControlLabel
                                        key={rating}
                                        control={
                                            <Checkbox
                                                checked={minRating === rating}
                                                onChange={() => setMinRating(minRating === rating ? 0 : rating)}
                                                size="small"
                                            />
                                        }
                                        label={`${rating}★ & above`}
                                    />
                                ))}
                            </FormControl>
                        </AccordionDetails>
                    </Accordion>
                </Box>

                {/* Results Container */}
                <Box className={classes.resultsContainer}>
                    {/* Search Header */}
                    <Box className={classes.searchHeader}>
                        <Box className={classes.sortContainer}>
                            <Box>
                                <Typography className={classes.searchTerm}>
                                    Search results for "{searchTerm}"
                                </Typography>
                                <Typography className={classes.resultsCount}>
                                    {filteredProducts.length} results found
                                </Typography>
                            </Box>
                            <FormControl size="small" className={classes.sortSelect}>
                                <Select
                                    value={sortBy}
                                    onChange={(e) => setSortBy(e.target.value)}
                                    displayEmpty
                                >
                                    <MenuItem value="relevance">Sort by Relevance</MenuItem>
                                    <MenuItem value="price-low-high">Price: Low to High</MenuItem>
                                    <MenuItem value="price-high-low">Price: High to Low</MenuItem>
                                    <MenuItem value="rating">Customer Rating</MenuItem>
                                    <MenuItem value="discount">Discount</MenuItem>
                                </Select>
                            </FormControl>
                        </Box>
                    </Box>

                    {/* Active Filters */}
                    {(selectedBrands.length > 0 || selectedCategories.length > 0 || minRating > 0) && (
                        <Box style={{ marginBottom: '12px' }}>
                            {selectedBrands.map(brand => (
                                <Chip
                                    key={brand}
                                    label={`Brand: ${brand}`}
                                    onDelete={() => handleBrandChange(brand)}
                                    style={{ margin: '4px' }}
                                    size="small"
                                />
                            ))}
                            {selectedCategories.map(category => (
                                <Chip
                                    key={category}
                                    label={`Category: ${category}`}
                                    onDelete={() => handleCategoryChange(category)}
                                    style={{ margin: '4px' }}
                                    size="small"
                                />
                            ))}
                            {minRating > 0 && (
                                <Chip
                                    label={`Rating: ${minRating}★ & above`}
                                    onDelete={() => setMinRating(0)}
                                    style={{ margin: '4px' }}
                                    size="small"
                                />
                            )}
                        </Box>
                    )}

                    {/* Search Results */}
                    {filteredProducts.length > 0 ? (
                        <Grid container spacing={0}>
                            {filteredProducts.map((product) => (
                                <Grid item xs={12} key={product.id || product._id}>
                                    <Link 
                                        to={`/product/${product.id || product._id}`} 
                                        style={{ textDecoration: 'none' }}
                                        onClick={() => handleProductClick(product.id || product._id)}
                                    >
                                        <Card className={classes.productCard} elevation={0}>
                                            <Box display="flex">
                                                {/* Product Image */}
                                                <Box>
                                                    <img 
                                                        src={product.url} 
                                                        alt={product.title?.longTitle}
                                                        className={classes.productImage}
                                                    />
                                                </Box>

                                                {/* Product Details */}
                                                <Box className={classes.productDetails}>
                                                    <Typography className={classes.productTitle}>
                                                        {product.title?.longTitle}
                                                    </Typography>

                                                    {/* Rating */}
                                                    <Box className={classes.ratingContainer}>
                                                        <Box className={classes.rating}>
                                                            <Star style={{ fontSize: '12px', marginRight: '2px' }} />
                                                            {product.rating || 4.2}
                                                        </Box>
                                                        <Typography className={classes.reviewCount}>
                                                            (1,234 reviews)
                                                        </Typography>
                                                    </Box>

                                                    {/* Price */}
                                                    <Box className={classes.priceContainer}>
                                                        <Typography className={classes.currentPrice}>
                                                            ₹{product.price?.cost?.toLocaleString('en-IN')}
                                                        </Typography>
                                                        <Typography className={classes.originalPrice}>
                                                            ₹{product.price?.mrp?.toLocaleString('en-IN')}
                                                        </Typography>
                                                        <Typography className={classes.discount}>
                                                            {product.price?.discount} off
                                                        </Typography>
                                                    </Box>

                                                    {/* Features */}
                                                    <Typography className={classes.features}>
                                                        {product.description ? 
                                                            product.description.substring(0, 150) + '...' : 
                                                            'No description available'
                                                        }
                                                    </Typography>

                                                    {/* Brand */}
                                                    {product.brand && (
                                                        <Box mt={1}>
                                                            <Chip 
                                                                label={product.brand} 
                                                                size="small" 
                                                                style={{ 
                                                                    background: '#e3f2fd', 
                                                                    color: '#1976d2',
                                                                    fontSize: '11px'
                                                                }} 
                                                            />
                                                        </Box>
                                                    )}
                                                </Box>
                                            </Box>
                                        </Card>
                                    </Link>
                                </Grid>
                            ))}
                        </Grid>
                    ) : (
                        <Box className={classes.noResults}>
                            <Typography variant="h6" gutterBottom>
                                No products found
                            </Typography>
                            <Typography color="textSecondary">
                                Try adjusting your search terms or filters
                            </Typography>
                        </Box>
                    )}
                </Box>
            </Box>
        </Box>
    );
};

export default SearchResultsPage;
</file>

<file path="SRP/scripts/bulk_indexer.py">
import pandas as pd
import sys
from pathlib import Path
from tqdm import tqdm

# Add app directory to path
sys.path.append(str(Path(__file__).resolve().parent.parent))

from app.models.model_loader import get_embedding_model
from app.db.chroma_manager import ChromaManager
from app.core.config import (
    PRODUCT_DATA_PATH, CATEGORY_DATA_PATH,
    PRODUCT_COLLECTION_NAME, CATEGORY_COLLECTION_NAME, BATCH_SIZE
)

def clean_product_data(df: pd.DataFrame) -> pd.DataFrame:
    df.dropna(subset=['pid', 'product_name', 'description'], inplace=True)
    df.drop_duplicates(subset=['pid'], keep='first', inplace=True)
    df['subcategory'] = df['subcategory'].astype(str).str.strip()
    df['combined_text'] = (
        df['product_name'].astype(str) + ". " +
        df['brand'].fillna('Unknown').astype(str) + ". " +
        df['description'].astype(str)
    )
    return df

def index_products(chroma_manager, embed_model):
    print("\n--- Starting Product Indexing ---")
    df = pd.read_csv(PRODUCT_DATA_PATH)
    df_cleaned = clean_product_data(df)
    
    print(f"Processing {len(df_cleaned)} products in batches of {BATCH_SIZE}...")
    
    # Use tqdm to show progress over the batches
    for i in tqdm(range(0, len(df_cleaned), BATCH_SIZE)):
        batch_df = df_cleaned.iloc[i : i + BATCH_SIZE]

        # Prepare data ONLY for this batch
        ids = batch_df["pid"].tolist()
        documents = batch_df["combined_text"].tolist()
        metadatas = batch_df[["subcategory"]].to_dict('records')
        
        # Generate embeddings ONLY for this batch
        embeddings = embed_model.encode(documents, show_progress_bar=False) # No need for inner progress bar
        
        # Add this complete batch to the collection
        chroma_manager.add_items_to_collection(
            collection_name=PRODUCT_COLLECTION_NAME,
            ids=ids,
            documents=documents,
            embeddings=embeddings.tolist(),
            metadatas=metadatas
        )
    print(f"Product indexing for collection '{PRODUCT_COLLECTION_NAME}' complete.")

def index_categories(chroma_manager, embed_model):
    print("\n--- Starting Category Indexing ---")
    df = pd.read_csv(CATEGORY_DATA_PATH)
    
    # --- Data Cleaning and Preparation ---
    # Drop rows where either column is missing
    df.dropna(subset=['subcategory', 'search_string'], inplace=True)
    
    # Clean both columns
    df['subcategory'] = df['subcategory'].astype(str).str.strip()
    df['search_string'] = df['search_string'].astype(str).str.strip()
    

    category_df = df.drop_duplicates()

    print(f"Processing {len(category_df)} search strings...")

    # Iterate through the de-duplicated DataFrame in batches
    for i in tqdm(range(0, len(category_df), BATCH_SIZE)):
        batch_df = category_df.iloc[i : i + BATCH_SIZE]
        
        # The ID is the cleaned subcategory name combined with the search string
        # This ensures uniqueness and clarity in the ID
        ids = [f"{row['subcategory']}_{row['search_string']}" for _, row in batch_df.iterrows()]

        # The document to be embedded is the corresponding search_string
        documents_to_embed = batch_df['search_string'].tolist()
        # documents_to_embed = batch_df['subcategory'].tolist()
        
        # The document stored in Chroma can be the subcategory name itself for clarity in logs
        stored_documents = batch_df['subcategory'].tolist()

        embeddings = embed_model.encode(documents_to_embed, show_progress_bar=False)
        
        chroma_manager.add_items_to_collection(
            collection_name=CATEGORY_COLLECTION_NAME,
            ids=ids,
            # We store the simple subcategory name as the "document" for easy viewing,
            # but the embedding is based on the richer search_string.
            documents=stored_documents,
            embeddings=embeddings.tolist()
        )
    print(f"Category indexing for collection '{CATEGORY_COLLECTION_NAME}' complete.")

def main():
    print("Initializing components for bulk indexing...")
    embed_model = get_embedding_model()
    chroma_manager = ChromaManager()

    index_products(chroma_manager, embed_model)
    index_categories(chroma_manager, embed_model)

    print("\n--- Bulk Indexing Complete for all collections! ---")

if __name__ == "__main__":
    main()
</file>

<file path="SRP/docker-compose.yml">
version: '3.8'

services:
  srp_api:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: flipkart_srp_api
    ports:
      - "8001:8000"
    volumes:
      - ./app:/app/app
      - ./scripts:/app/scripts
      - chroma_db_data:/app/db_storage
      - ./data:/app/data  # <--- ADD THIS LINE
    restart: unless-stopped
    # The 'deploy' section for GPU has been completely removed.

    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

volumes:
  chroma_db_data:
</file>

<file path="server/controller/search-controller.js">
import Product from '../model/productSchema.js';
import Category from '../model/categorySchema.js';
import { esClient } from '../index.js';
import { updateUserProfile, getUserProfile, redisClient } from '../database/redis.js';
import { expandQueryWithAbbreviations } from '../constants/abbreviations.js';
import axios from 'axios'; // <-- Make sure to import axios

const indexName = 'products';

// UPDATED: Enhanced regex escape to handle trailing/invalid backslashes (double-escape '\')
function escapeRegex(text) {
    return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&').replace(/\\/g, '\\\\');
}

// --- Personalized Search Controller: Returns ranked products + category suggestions ---
export const personalizedSearch = async (req, res) => {
    const { q: searchQuery } = req.query;
    if (!searchQuery) {
        return res.status(400).send('Query "q" is required.');
    }

    try {
        // 1. Call the SRP service to get ranked product IDs
        console.log(`[Node Server] Calling SRP service for query: "${searchQuery}"`);
        const srpResponse = await axios.post('http://localhost:8001/api/search', {
            query: searchQuery
        });

        const ranked_ids = srpResponse.data.ranked_ids;

        if (!ranked_ids || ranked_ids.length === 0) {
            return res.json([]); // Return empty if SRP found no results
        }

        console.log(`[Node Server] Received ${ranked_ids.length} ranked IDs from SRP.`);

        // 2. Fetch full product details from MongoDB for the ranked IDs
        const products = await Product.find({ id: { $in: ranked_ids } });

        // 3. Create a map for quick lookup to preserve the order from SRP
        const productMap = new Map();
        products.forEach(product => {
            // Use 'id' field which corresponds to 'pid' from your CSV
            productMap.set(product.id, product);
        });

        // 4. Re-sort the fetched products based on the SRP's ranking
        const sortedProducts = ranked_ids
            .map(id => productMap.get(id))
            .filter(product => product !== undefined); // Filter out any products not found in DB

        console.log(`[Node Server] Returning ${sortedProducts.length} full product objects to client.`);
        
        // 5. Respond to the client
        res.json(sortedProducts);

    } catch (error) {
        console.error('Error in personalizedSearch calling SRP service:', error.response ? error.response.data : error.message);
        // Implement a fallback to your old search logic if you want
        // For now, we just return an error
        res.status(500).json({ error: 'Failed to retrieve search results.' });
    }
};


// --- Click Tracking for personalization ---
export const trackClick = async (req, res) => {
    const { userId, productId, category } = req.body;
    if (!userId) {
        return res.status(400).json({ message: 'userId is required' });
    }

    try {
        // Existing: Update clicked products if productId provided
        if (productId) {
            await updateUserProfile(userId, productId);

            // NEW: Track categories from the clicked product (with safe fetch)
            let product;
            try {
                // Skip findById if productId looks like a PID (not 24 hex chars) to avoid CastError
                if (/^[0-9a-fA-F]{24}$/.test(productId)) {
                    product = await Product.findById(productId);
                }
                // Fallback to pid or id fields (your CSV-based identifiers)
                if (!product) {
                    product = await Product.findOne({
                        $or: [{ pid: productId }, { id: productId }]
                    });
                }
                if (!product) {
                    console.warn(`Product not found for ID/PID: ${productId} - Skipping category tracking`);
                }
            } catch (fetchError) {
                // Log but don't crash - continue without category tracking
                console.error(`Error fetching product ${productId}:`, fetchError.message);
            }

            if (product && (product.category || product.subcategory)) {
                const categories = [product.category, product.subcategory].filter(Boolean); // Get unique category/subcategory
                const profile = await getUserProfile(userId); // Reuse existing profile fetch
                profile.clicked_categories = profile.clicked_categories || [];
                
                // Add new categories to the front (for recency), remove duplicates, limit to 10
                categories.forEach(cat => {
                    profile.clicked_categories = profile.clicked_categories.filter(c => c !== cat);
                    profile.clicked_categories.unshift(cat);
                });
                profile.clicked_categories = profile.clicked_categories.slice(0, 10); // Limit history

                // NEW: Ensure client is connected before set
                if (!redisClient.isOpen) await redisClient.connect();
                await redisClient.set(`user:${userId}`, JSON.stringify(profile)); // Update Redis
                console.log(`User ${userId} clicked categories updated: ${categories}`);
            }
        }

        // NEW: Handle direct category/subcategory clicks (if category provided)
        if (category) {
            const profile = await getUserProfile(userId);
            profile.clicked_categories = profile.clicked_categories || [];
            
            // Add new category to the front (for recency), remove duplicates, limit to 10
            profile.clicked_categories = profile.clicked_categories.filter(c => c !== category);
            profile.clicked_categories.unshift(category);
            profile.clicked_categories = profile.clicked_categories.slice(0, 10); // Limit history

            // Ensure client is connected before set
            if (!redisClient.isOpen) await redisClient.connect();
            await redisClient.set(`user:${userId}`, JSON.stringify(profile)); // Update Redis
            console.log(`User ${userId} clicked category updated: ${category}`);
        }

        return res.status(200).json({ message: 'Click tracked successfully' });
    } catch (error) {
        console.error('trackClick error:', error);
        return res.status(500).json({ message: 'Failed to track click' });
    }
};

// --- Autosuggest for search bar: concise categories + product titles ---
export const autosuggest = async (req, res) => {
    const { q } = req.query;
    if (!q || !q.trim()) return res.json([]);
    
    const originalQuery = q.trim();
    const query = originalQuery.toLowerCase();
    
    // Existing abbreviation expansion logic (UNCHANGED)
    const expandedQuery = expandQueryWithAbbreviations(originalQuery);
    const searchQuery = expandedQuery !== originalQuery ? expandedQuery.toLowerCase() : query;

    // Existing personalization logic (UNCHANGED)
    let boostProducts = [];
    let boostCategories = []; 
    try {
        const userId = req.query.userId;
        if (userId) {
            const profile = await getUserProfile(userId);
            boostProducts = profile?.clicked_products || [];
            boostCategories = profile?.clicked_categories || [];
        }
    } catch (redisError) {
        console.error('Redis error in autosuggest:', redisError);
    }
    const boostWords = new Set();
    if (boostCategories.length > 0) {
        boostCategories.forEach(cat => {
            // Split phrases like "Men Formal Shoes" into individual words
            cat.toLowerCase().split(' ').forEach(word => boostWords.add(word));
        });
        // Now boostWords might contain: {'men', 'formal', 'shoes', 'disney', 'casual'}
    }


    try {
        // --- PRIMARY ELASTICSEARCH PATH ---
        const escapedQuery = escapeRegex(searchQuery);
        const escapedOriginalQuery = escapeRegex(query);

        // Existing Elasticsearch product search (UNCHANGED)
        const { hits } = await esClient.search({
            index: indexName,
            query: {
                bool: {
                    should: [
                        { multi_match: { query: searchQuery, fields: ['name^2', 'category'], fuzziness: 'AUTO', type: 'best_fields' } },
                        { multi_match: { query: query, fields: ['name^2', 'category'], fuzziness: 'AUTO', type: 'best_fields' } },
                        { terms: { _id: boostProducts } }
                    ]
                }
            },
            highlight: {
                fields: {
                    name: { pre_tags: ['<strong>'], post_tags: ['</strong>'] },
                    category: { pre_tags: ['<strong>'], post_tags: ['</strong>'] }
                }
            },
            sort: [{ rating: { order: 'desc' } }, '_score'],
            size: 5 // Reduced size to prioritize better category/term matches
        });

        // Existing product suggestion mapping and scoring (UNCHANGED)
        let productSuggestions = hits.hits.map(hit => {
            const nameLower = (hit._source.name || '').toLowerCase();
            const categoryLower = (hit._source.category || '').toLowerCase();
            let score = 0;
            if (boostProducts.includes(hit._id)) score += 1000;
            if (nameLower === searchQuery || nameLower === query) score += 900;
            else if (nameLower.startsWith(searchQuery) || nameLower.startsWith(query)) score += 500;
            else if (nameLower.includes(searchQuery) || nameLower.includes(query)) score += 100;
            if (categoryLower.startsWith(searchQuery) || categoryLower.startsWith(query)) score += 200;
            else if (categoryLower.includes(searchQuery) || categoryLower.includes(query)) score += 50;
            
            return {
                type: 'product',
                id: hit._id,
                title: {
                    longTitle: hit.highlight?.name?.[0] || hit._source.name,
                    shortTitle: hit.highlight?.category?.[0] || hit._source.category
                },
                rating: hit._source.rating,
                score
            };
        });

        // Category/Subcategory/Search-String suggestions from MongoDB
        try {
            const catMatches = await Category.find({
                $or: [
                    { category: { $regex: escapedQuery, $options: 'i' } },
                    { subcategory: { $regex: escapedQuery, $options: 'i' } },
                    { search_string: { $regex: escapedQuery, $options: 'i' } },
                    { category: { $regex: escapedOriginalQuery, $options: 'i' } },
                    { subcategory: { $regex: escapedOriginalQuery, $options: 'i' } },
                    { search_string: { $regex: escapedOriginalQuery, $options: 'i' } }
                ]
            }).limit(20);

            const cats = [];
            catMatches.forEach(c => {
                if (c.category && (c.category.toLowerCase().includes(searchQuery) || c.category.toLowerCase().includes(query)))
                    cats.push({ type: 'category', name: c.category });
                if (c.subcategory && (c.subcategory.toLowerCase().includes(searchQuery) || c.subcategory.toLowerCase().includes(query)))
                    cats.push({ type: 'subcategory', name: c.subcategory });
                if (c.search_string && (c.search_string.toLowerCase().includes(searchQuery) || c.search_string.toLowerCase().includes(query))) {
                    cats.push({ type: 'search_term', name: c.search_string, subcategory: c.subcategory });
                }
            });

            // --- ENHANCEMENT: Aggressive scoring to prioritize relevance over weak product matches ---
            let scoredCats = cats.map(cat => {
                const nameLower = cat.name.toLowerCase();
                let score = 0;
                const targetCat = cat.subcategory || cat.name;
                if (boostCategories.includes(targetCat)) score += 1000;
                if (boostWords.size > 0) {
                    const candidateWords = nameLower.split(' ');
                    let matchCount = 0;
                    candidateWords.forEach(word => {
                        if (boostWords.has(word)) {
                            matchCount++;
                        }
                    });
                    // Give a strong boost for each shared keyword found
                    if (matchCount > 0) {
                        score += 800 * matchCount;
                    }
                }
                // These scores are intentionally higher than product scores to ensure they rank first
                if (nameLower === query || nameLower === searchQuery) {
                    score += 2000; // Exact match is the best signal
                } else if (nameLower.startsWith(query) || nameLower.startsWith(searchQuery)) {
                    score += 1500; // Prefix match is very strong
                } else if (nameLower.includes(query) || nameLower.includes(searchQuery)) {
                    score += 100; // Contains match is a basic signal
                }
                
                // Add inherent boosts based on suggestion type specificity
                if (cat.type === 'search_term') score += 200;
                if (cat.type === 'subcategory') score += 150;

                return { ...cat, score };
            });

            // --- ENHANCEMENT: More robust combination logic ---
            const allSuggestions = [...productSuggestions, ...scoredCats];
            allSuggestions.sort((a,b) => (b.score || 0) - (a.score || 0));

            const finalSuggestions = [];
            const seenNames = new Set();
            for(const item of allSuggestions) {
                if(finalSuggestions.length >= 8) break;
                const key = item.type === 'product' ? item.id : item.name;
                if(!seenNames.has(key)) {
                    finalSuggestions.push(item);
                    seenNames.add(key);
                }
            }

            return res.json(finalSuggestions);

        } catch (mongoError) {
            console.error('Mongo category error in autosuggest:', mongoError);
            return res.json(productSuggestions.sort((a, b) => b.score - a.score).slice(0, 8)); // Fallback to just sorted products if Mongo fails
        }

    } catch (err) {
        // --- MONGODB FALLBACK PATH ---
        console.error('ES error in autosuggest, using Mongo fallback:', err.message);
        try {
            const escapedQuery = escapeRegex(searchQuery);
            const escapedOriginalQuery = escapeRegex(query);
            
            let products = await Product.find({
                $or: [
                    { 'title.longTitle': { $regex: escapedQuery, $options: 'i' } },
                    { 'title.shortTitle': { $regex: escapedQuery, $options: 'i' } },
                    { 'title.longTitle': { $regex: escapedOriginalQuery, $options: 'i' } },
                    { 'title.shortTitle': { $regex: escapedOriginalQuery, $options: 'i' } }
                ]
            }).sort({ rating: -1 }).limit(5);

            products = products.sort((a, b) => 
                (boostProducts.includes(b._id.toString()) ? 1 : 0) - (boostProducts.includes(a._id.toString()) ? 1 : 0)
            );

            // --- ENHANCEMENT: Added full scoring logic to fallback's product mapping ---
            let productSuggestions = products.map(p => {
                const longTitleLower = p.title.longTitle.toLowerCase();
                const shortTitleLower = p.title.shortTitle.toLowerCase();
                let score = 0;
                if (boostProducts.includes(p._id.toString())) score += 1000;
                if (longTitleLower === searchQuery || longTitleLower === query) score += 900;
                else if (longTitleLower.startsWith(searchQuery) || longTitleLower.startsWith(query)) score += 500;
                else if (longTitleLower.includes(searchQuery) || longTitleLower.includes(query)) score += 100;
                if (shortTitleLower.startsWith(searchQuery) || shortTitleLower.startsWith(query)) score += 200;
                else if (shortTitleLower.includes(searchQuery) || shortTitleLower.includes(query)) score += 50;
                
                const longTitle = p.title.longTitle.replace(new RegExp(escapedQuery, 'gi'), match => `<strong>${match}</strong>`);
                const shortTitle = p.title.shortTitle.replace(new RegExp(escapedQuery, 'gi'), match => `<strong>${match}</strong>`);
                
                return {
                    type: 'product', id: p._id.toString(), title: { longTitle, shortTitle }, rating: p.rating, score
                };
            });

            const catMatches = await Category.find({
                $or: [
                    { category: { $regex: escapedQuery, $options: 'i' } },
                    { subcategory: { $regex: escapedQuery, $options: 'i' } },
                    { search_string: { $regex: escapedQuery, $options: 'i' } },
                    { category: { $regex: escapedOriginalQuery, $options: 'i' } },
                    { subcategory: { $regex: escapedOriginalQuery, $options: 'i' } },
                    { search_string: { $regex: escapedOriginalQuery, $options: 'i' } }
                ]
            }).limit(20);
            
            const cats = [];
            catMatches.forEach(c => {
                if (c.category && (c.category.toLowerCase().includes(searchQuery) || c.category.toLowerCase().includes(query)))
                    cats.push({ type: 'category', name: c.category });
                if (c.subcategory && (c.subcategory.toLowerCase().includes(searchQuery) || c.subcategory.toLowerCase().includes(query)))
                    cats.push({ type: 'subcategory', name: c.subcategory });
                if (c.search_string && (c.search_string.toLowerCase().includes(searchQuery) || c.search_string.toLowerCase().includes(query))) {
                    cats.push({ type: 'search_term', name: c.search_string, subcategory: c.subcategory });
                }
            });

            // --- ENHANCEMENT: Mirrored aggressive scoring in the fallback path ---
            let scoredCats = cats.map(cat => {
                const nameLower = cat.name.toLowerCase();
                let score = 0;
                const targetCat = cat.subcategory || cat.name;
                if (boostCategories.includes(targetCat)) score += 1000;
                
                if (nameLower === query || nameLower === searchQuery) score += 2000;
                else if (nameLower.startsWith(query) || nameLower.startsWith(searchQuery)) score += 1500;
                else if (nameLower.includes(query) || nameLower.includes(searchQuery)) score += 100;
                
                if (cat.type === 'search_term') score += 200;
                if (cat.type === 'subcategory') score += 150;

                return { ...cat, score };
            });
            
            // Unchanged combination logic
            const allSuggestions = [...productSuggestions, ...scoredCats];
            allSuggestions.sort((a,b) => (b.score || 0) - (a.score || 0));

            const finalSuggestions = [];
            const seenNames = new Set();
            for(const item of allSuggestions) {
                if(finalSuggestions.length >= 8) break;
                const key = item.type === 'product' ? item.id : item.name;
                if(!seenNames.has(key)) {
                    finalSuggestions.push(item);
                    seenNames.add(key);
                }
            }
            
            return res.json(finalSuggestions);

        } catch (mongoError) {
            console.error('Mongo fallback error in autosuggest:', mongoError);
            return res.json([]);
        }
    }
};
</file>

<file path="README.md">
# Flipkart Grid Search: AI-Powered Semantic Search Engine 🚀

![Status](https://img.shields.io/badge/status-production_ready-green)
![React](https://img.shields.io/badge/React-17.0.2-blue?logo=react)
![Node.js](https://img.shields.io/badge/Node.js-16.x-green?logo=node.js)
![Python](https://img.shields.io/badge/Python-3.12-blue?logo=python)
![MongoDB](https://img.shields.io/badge/MongoDB-5.x-green?logo=mongodb)
![Elasticsearch](https://img.shields.io/badge/Elasticsearch-7.x-blue?logo=elasticsearch)
![Redis](https://img.shields.io/badge/Redis-6.x-red?logo=redis)

This repository delivers an enterprise-grade, AI-powered personalized e-commerce search engine. It moves beyond simple keyword matching to **understand user intent**, delivering a hyper-relevant, intelligent, and incredibly fast shopping experience modeled after Flipkart's advanced search capabilities.

-----

## 🌟 Key Features

| Feature                          | Description                                                                                                                                                             |
| -------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ✅ **Semantic Search Pipeline (SRP)** | A Python microservice using ML models to understand the *meaning* behind a query, not just the words. Handles typos and finds related products effortlessly.       |
| ✅ **Intent Classification**     | Before searching, the SRP classifies your query (e.g., "cheap running shoes") into a product category ("Men's Sports Shoes") for laser-focused results.                  |
| ✅ **Intelligent Autosuggest**   | A hybrid system using Elasticsearch provides instant suggestions for products, categories, *and* specific search phrases (e.g., "top load washing machine").           |
| ✅ **Real-Time Personalization** | Using Redis, the engine tracks user clicks on products and categories to boost their rankings in subsequent searches and suggestions, all in real-time.                 |
| ✅ **Abbreviation Expansion**    | Automatically expands common e-commerce shorthand (e.g., "tv" -> "Televisions", "ac" -> "Air Conditioners") for both search and autosuggest, improving accuracy. |
| ✅ **Robust Microservice Arch.**   | A decoupled frontend, Node.js gateway, and Python ML service make the system scalable, maintainable, and resilient.                                                   |
| ✅ **Advanced Filtering & UI**   | A fast, responsive React/Material-UI frontend with comprehensive filters for price, brand, category, and rating, enabling users to drill down to what they need.       |


-----
## 🏗️ System Architecture

Our architecture is a carefully orchestrated dance between specialized services, ensuring both speed and intelligence. The Node.js server acts as the central gateway, delegating tasks to the optimal engine for the job.

```mermaid
graph TB
    subgraph " "
        direction LR
        subgraph "Client Layer"
            A[<img src='https://www.vectorlogo.zone/logos/reactjs/reactjs-icon.svg' width='30' /><br>React Frontend]
        end
        subgraph "Gateway & Caching Layer"
            B[<img src='https://www.vectorlogo.zone/logos/nodejs/nodejs-icon.svg' width='30' /><br>Node.js API Gateway]
            C[<img src='https://www.vectorlogo.zone/logos/redis/redis-icon.svg' width='30' /><br>Redis Personalization Cache]
        end
        subgraph "Intelligence & Search Layer"
            D[<img src='https://www.vectorlogo.zone/logos/python/python-icon.svg' width='30' /><br>Python SRP Service]
            E[<img src='https://www.vectorlogo.zone/logos/elastic/elastic-icon.svg' width='30' /><br>Elasticsearch Autosuggest Engine]
        end
        subgraph "Data Persistence Layer"
            F[<img src='https://www.trychroma.com/favicon.ico' width='30' /><br>ChromaDB Vector Store]
            G[<img src='https://www.vectorlogo.zone/logos/mongodb/mongodb-icon.svg' width='30' /><br>MongoDB Product & Term Database]
        end
    end

    A -- "API Calls" --> B
    B -- "Real-time Personalization" <--> C
    B -- "Semantic Search Request" --> D
    B -- "Fast Autosuggest" --> E
    B -- "Hydrate Results & Get Term Data" --> G
    D -- "Vector Search" --> F
```

-----

## 🔄 The Hybrid Search Flow: A Tale of Two Queries

Our system uses two distinct pipelines for a superior user experience: one for lightning-fast suggestions, and another for deep, intelligent search results.

```mermaid
sequenceDiagram
    participant U as User
    participant UI as React Frontend
    participant API as Node.js Gateway
    participant ES as Elasticsearch
    participant SRP as Python SRP
    participant DB as MongoDB
    
    U->>UI: Types "washin machin"
    
    %% Autosuggest Flow
    UI->>API: /autosuggest?q=washin machin
    API->>ES: Multi-search on 'products' & 'search_terms'
    ES-->>API: Returns "Washing Machines", "top load...", etc.
    API-->>UI: Displays ranked suggestions
    UI-->>U: Shows "top load washing machine"

    %% Full Search Flow
    U->>UI: Clicks "top load washing machine" suggestion
    UI->>API: /search?q=top load washing machine
    API->>DB: Finds term is linked to "Washing Machines" subcategory
    API->>SRP: POST /api/search { query: "Washing Machines" }
    SRP->>ChromaDB: Vector search for "Washing Machines"
    SRP-->>API: Returns ranked list of product IDs
    API->>DB: Fetches full details for ranked IDs
    API-->>UI: Returns final, sorted product list
    UI-->>U: Displays highly relevant washing machines
```

-----

## 🧮 Algorithms & Intelligence

### 1. Autosuggest Scoring (Elasticsearch & Node.js)

For instant suggestions, we use a custom scoring model in Node.js on top of Elasticsearch's powerful text search.

```javascript
// Scoring Priorities for Autosuggest (Higher = Better Rank)
const scoringWeights = {
  personalization: 1000, // Recently clicked items from Redis
  exactMatch: 900,       // Query matches a full term
  prefixMatch: 500,      // Term starts with the query
  substringMatch: 100,   // Term contains the query
};
```

### 2. Semantic Search Pipeline (Python SRP)

Our Search Results Page (SRP) uses a rigorously validated, multi-stage pipeline to ensure highly relevant and diverse results:

1. **Intent Classification & Result Diversification**  
   - We embed the user’s query (e.g. “Washing Machines”) into a vector.  
   - That embedding is compared not only to subcategory names, but also to their standardized abbreviations and a curated set of related terms in our **ChromaDB** category index.  
   - We then select the top *K* **unique** subcategories—ensuring that we cover distinct facets of the user’s intent and maximize result diversification.  

2. **Candidate Retrieval**  
   - For each of those *K* subcategories, we perform a vector search in the **ChromaDB** product index.  
   - We retrieve the top *M* products per category, giving us a pool of *K × M* candidates that are all semantically close to the query.  

3. **Cross-Encoder Reranking**  
   - A state-of-the-art Cross-Encoder model takes the original query and each candidate’s metadata (title, description, attributes).  
   - It produces a fine-grained relevance score for every candidate.  
   - We sort the *K × M* set by this score to produce a final, precision-optimized ranking of product IDs, which is returned in the API response.  

This design guarantees both **deep semantic understanding** of user intent and **result diversification**, while leveraging a powerful Cross-Encoder for ultimate ranking accuracy.  


-----

## 🛠️ Getting Started: A Foolproof 4-Terminal Setup

This is a multi-service application. The easiest way to run it is with four separate terminal windows.

### Prerequisites

*   Node.js (v16+) & npm
*   Python (v3.10+) & pip
*   Docker & Docker Compose (or a local ChromaDB install)

### Step 1: Clone the Repository & Configure

```bash
git clone https://github.com/your-username/flipkart-grid-search.git
cd flipkart-grid-search

# Create the .env file for the Node server
cp server/.env.example server/.env
# NOW, EDIT server/.env and add your MongoDB Atlas password
```

### Step 2: Run the Services

Open four terminals, one for each step.

**➡️ Terminal 1: Start the Backend Server (Node.js)**
This server also handles Elasticsearch and Redis connections.
```bash
cd server
npm install
npm start
```
*This server runs on `http://localhost:8000`.*

**➡️ Terminal 2: Start the SRP Microservice (Python)**
```bash
cd SRP
# It's recommended to use a virtual environment
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
uvicorn app.main:app --host 0.0.0.0 --port 8001
```
*This service runs on `http://localhost:8001`.*

**➡️ Terminal 3: Start the Frontend (React)**
```bash
cd client
npm install
npm start
```
*Your application will be available at `http://localhost:3000`.*

**➡️ Terminal 4: Index Your Data (One-Time Setup)**
This step is **critical** and populates your databases. Run these commands from the project root.
```bash
# 1. Populate MongoDB with product data
(cd server && node importData.js)

# 2. Populate MongoDB with category & search term data
(cd server && node importCategories.js)
(cd server && node importSearchTerms.js)

# 3. Populate ChromaDB (Vector DB) for the SRP
# Ensure you are in the SRP virtual environment first!
(cd SRP && source venv/bin/activate && python scripts/bulk_indexer.py)
```
After indexing, **restart the Node.js server (Terminal 1)** for it to create the Elasticsearch indices with the new data.

**You are all set!** Open `http://localhost:3000` and experience the search.

-----

## 🧩 Tech Stack Deep Dive

| Layer                      | Tech                                                                                                   | Purpose                                                                          |
| -------------------------- | ------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------- |
| **Frontend**               | <img src='https://www.vectorlogo.zone/logos/reactjs/reactjs-icon.svg' width='20' /> React, Material-UI | Building a fast, responsive, and modern user interface.                          |
| **Gateway & API**          | <img src='https://www.vectorlogo.zone/logos/nodejs/nodejs-icon.svg' width='20' /> Node.js (Express)      | Orchestrates all backend services, handles authentication, and serves API endpoints. |
| **Semantic Search (ML)**   | <img src='https://www.vectorlogo.zone/logos/python/python-icon.svg' width='20' /> Python (FastAPI)       | The AI brain. Handles intent classification, semantic retrieval, and reranking.  |
| **Vector Database**        | <img src='https://www.trychroma.com/favicon.ico' width='20' /> ChromaDB                                 | Stores and enables ultra-fast similarity search on ML model embeddings.          |
| **Primary Data Store**     | <img src='https://www.vectorlogo.zone/logos/mongodb/mongodb-icon.svg' width='20' /> MongoDB                | Stores all product, category, and search term data.                              |
| **Real-time Personalization** | <img src='https://www.vectorlogo.zone/logos/redis/redis-icon.svg' width='20' /> Redis                  | Caches user clickstream data for instant personalization boosts.                 |
| **Autosuggest Engine**     | <img src='https://www.vectorlogo.zone/logos/elastic/elastic-icon.svg' width='20' /> Elasticsearch        | Provides lightning-fast, prefix-based search for the autosuggest dropdown.         |
</file>

<file path="client/src/Components/Header/Search.jsx">
import { useState, useEffect, useRef, useContext } from 'react';
import { InputBase, List, ListItem, Typography, makeStyles, Box } from '@material-ui/core';
import { Search as SearchIcon, History as HistoryIcon } from '@material-ui/icons';
import { useHistory } from 'react-router-dom';
import axios from 'axios';
import DOMPurify from 'dompurify';
import { LoginContext } from '../../context/ContextProvider';

const useStyle = makeStyles(theme => ({
  search: {
    borderRadius: 2,
    marginLeft: 10,
    width: '560px', // Using a fixed width to match Flipkart's stable layout
    backgroundColor: '#f0f2f5',
    display: 'flex',
    // --- THIS IS THE FIX ---
    position: 'relative', // This makes the search bar the anchor for the dropdown
  },
  searchIconWrapper: {
    padding: '5px 12px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    color: '#2874f0',
    cursor: 'pointer',
  },
  inputRoot: {
    fontSize: '14px',
    width: '100%'
  },
  inputInput: {
    paddingLeft: 20,
    width: '100%',
  },
  listWrapper: {
    position: 'absolute',
    color: '#000',
    background: '#fff',
    top: 36, // Position it just below the search bar
    width: '100%', // Now this is 100% of the search bar's width
    borderRadius: '0 0 2px 2px',
    boxShadow: '0 2px 4px 0 rgb(0 0 0 / 20%)',
    borderTop: '1px solid #e0e0e0'
  },
  listItem: {
    padding: '10px 16px',
    display: 'flex',
    alignItems: 'center',
    gap: '12px',
    '&:hover': {
      backgroundColor: '#f8f9fa'
    }
  },
  suggestionText: {
    fontSize: '14px',
    color: '#212121',
  },
  suggestionType: {
    fontSize: '12px',
    color: '#878787',
    marginLeft: 'auto'
  },
  icon: {
    color: '#878787'
  }
}));

const Search = () => {
  const classes = useStyle();
  const history = useHistory();
  const [text, setText] = useState('');
  const [results, setResults] = useState([]);
  const suggestionCache = useRef(new Map());
  const { account } = useContext(LoginContext);

  // --- All your existing logic is preserved ---
  useEffect(() => {
    if (!text) {
      setResults([]);
      return;
    }
    const fetchSuggestions = async () => {
      if (suggestionCache.current.has(text)) {
        setResults(suggestionCache.current.get(text));
        return;
      }
      try {
        const { data } = await axios.get(
          `http://localhost:8000/autosuggest?q=${encodeURIComponent(text)}${account ? `&userId=${encodeURIComponent(account)}` : ''}`
        );
        setResults(data.slice(0, 8));
        suggestionCache.current.set(text, data.slice(0, 8));
      } catch (error) {
        console.error("Autosuggest API call failed:", error);
        setResults([]);
      }
    };
    const timeoutId = setTimeout(fetchSuggestions, 400);
    return () => clearTimeout(timeoutId);
  }, [text, account]);

  const handleTextChange = e => setText(e.target.value);
  const clearSearch = () => { setText(''); setResults([]); };

  const onSuggestionClick = async (suggestion) => {
    if (suggestion.type === 'product') {
      if (account && suggestion.id) {
        try { await axios.post('http://localhost:8000/click', { userId: account, productId: suggestion.id }); }
        catch (e) { console.error('Click tracking failed:', e); }
      }
      history.push(`/product/${suggestion.id}`);
    } else {
      let searchTarget = '';
      let displayQuery = '';
      if (suggestion.type === 'search_term') {
        searchTarget = suggestion.subcategory;
        displayQuery = suggestion.name;
      } else {
        searchTarget = suggestion.name;
        displayQuery = suggestion.name;
      }
      if (searchTarget && account) {
        try { await axios.post('http://localhost:8000/click', { userId: account, category: searchTarget }); }
        catch (e) { console.error('Category/Term click tracking failed:', e); }
      }
      history.push(`/search?q=${encodeURIComponent(searchTarget)}&oq=${encodeURIComponent(displayQuery)}`);
    }
    clearSearch();
  };

  const handleSearch = () => {
    const query = text.trim();
    if (!query) return;
    const topSuggestion = results?.[0];
    if (topSuggestion && topSuggestion.type === 'product' && topSuggestion.title?.longTitle) {
      const highlightedHTML = topSuggestion.title.longTitle;
      const match = highlightedHTML.match(/<strong>(.*?)<\/strong>/i);
      const correctedKeyword = match ? match[1] : query;
      history.push(`/search?q=${encodeURIComponent(correctedKeyword)}&oq=${encodeURIComponent(query)}`);
    } else if (topSuggestion && topSuggestion.type !== 'product') {
      onSuggestionClick(topSuggestion);
    } else {
      history.push(`/search?q=${encodeURIComponent(query)}&oq=${encodeURIComponent(query)}`);
    }
    clearSearch();
  };

  return (
    <Box className={classes.search}>
      <InputBase
        placeholder="Search for products, brands and more"
        classes={{ root: classes.inputRoot, input: classes.inputInput }}
        value={text}
        onChange={handleTextChange}
        onKeyDown={e => { if (e.key === 'Enter') handleSearch(); }}
      />
      <Box className={classes.searchIconWrapper} onClick={handleSearch}><SearchIcon /></Box>
      
      {results.length > 0 && (
        <List className={classes.listWrapper}>
          {results.map((suggestion, index) => (
            <ListItem
              button
              key={`${suggestion.type}-${index}`}
              onClick={() => onSuggestionClick(suggestion)}
              className={classes.listItem}
            >
              {suggestion.type === 'product' ? (
                <>
                  <SearchIcon className={classes.icon} />
                  <Typography className={classes.suggestionText}>
                    {suggestion.title.longTitle.replace(/<[^>]+>/g, '')}
                  </Typography>
                  <Typography className={classes.suggestionType}>
                    {suggestion.title.shortTitle}
                  </Typography>
                </>
              ) : (
                <>
                  <HistoryIcon className={classes.icon} />
                  <Typography className={classes.suggestionText}>
                    {suggestion.name}
                  </Typography>
                  <Typography className={classes.suggestionType}>
                    in {suggestion.type === 'search_term' ? suggestion.subcategory : suggestion.type}
                  </Typography>
                </>
              )}
            </ListItem>
          ))}
        </List>
      )}
    </Box>
  );
};

export default Search;
</file>

</files>
